#!/usr/bin/env bun
// @bun
import{createRequire as m2} from"node:module";var k2=Object.create;var{defineProperty:g1,getPrototypeOf:y2,getOwnPropertyNames:v2}=Object;var x2=Object.prototype.hasOwnProperty;var f2=($,K,Y)=>{Y=$!=null?k2(y2($)):{};const Z=K||!$||!$.__esModule?g1(Y,"default",{value:$,enumerable:!0}):Y;for(let Q of v2($))if(!x2.call(Z,Q))g1(Z,Q,{get:()=>$[Q],enumerable:!0});return Z};var M1=($,K)=>()=>(K||$((K={exports:{}}).exports,K),K.exports);var E=($,K)=>{for(var Y in K)g1($,Y,{get:K[Y],enumerable:!0,configurable:!0,set:(Z)=>K[Y]=()=>Z})};var L=($,K)=>()=>($&&(K=$($=0)),K);var k=m2(import.meta.url);var W;var D=L(()=>{W={cyan:(...$)=>`\x1B[36m${$.join(" ")}\x1B[0m`,red:(...$)=>`\x1B[31m${$.join(" ")}\x1B[0m`,yellow:(...$)=>`\x1B[33m${$.join(" ")}\x1B[0m`,green:(...$)=>`\x1B[32m${$.join(" ")}\x1B[0m`,blue:(...$)=>`\x1B[34m${$.join(" ")}\x1B[0m`,magenta:(...$)=>`\x1B[35m${$.join(" ")}\x1B[0m`,cyanBright:(...$)=>`\x1B[96m${$.join(" ")}\x1B[0m`,redBright:(...$)=>`\x1B[91m${$.join(" ")}\x1B[0m`,yellowBright:(...$)=>`\x1B[93m${$.join(" ")}\x1B[0m`,greenBright:(...$)=>`\x1B[92m${$.join(" ")}\x1B[0m`,blueBright:(...$)=>`\x1B[94m${$.join(" ")}\x1B[0m`,magentaBright:(...$)=>`\x1B[95m${$.join(" ")}\x1B[0m`,whiteBright:(...$)=>`\x1B[97m${$.join(" ")}\x1B[0m`,gray:(...$)=>`\x1B[90m${$.join(" ")}\x1B[0m`,grey:(...$)=>`\x1B[90m${$.join(" ")}\x1B[0m`,white:(...$)=>`\x1B[37m${$.join(" ")}\x1B[0m`,black:(...$)=>`\x1B[30m${$.join(" ")}\x1B[0m`,blackBright:(...$)=>`\x1B[90m${$.join(" ")}\x1B[0m`,bgCyan:(...$)=>`\x1B[46m${$.join(" ")}\x1B[0m`,bgRed:(...$)=>`\x1B[41m${$.join(" ")}\x1B[0m`,bgYellow:(...$)=>`\x1B[43m${$.join(" ")}\x1B[0m`,bgGreen:(...$)=>`\x1B[42m${$.join(" ")}\x1B[0m`,bgBlue:(...$)=>`\x1B[44m${$.join(" ")}\x1B[0m`,bgMagenta:(...$)=>`\x1B[45m${$.join(" ")}\x1B[0m`,bgCyanBright:(...$)=>`\x1B[106m${$.join(" ")}\x1B[0m`,bgRedBright:(...$)=>`\x1B[101m${$.join(" ")}\x1B[0m`,bgYellowBright:(...$)=>`\x1B[103m${$.join(" ")}\x1B[0m`,bgGreenBright:(...$)=>`\x1B[102m${$.join(" ")}\x1B[0m`,bgBlueBright:(...$)=>`\x1B[104m${$.join(" ")}\x1B[0m`,bgMagentaBright:(...$)=>`\x1B[105m${$.join(" ")}\x1B[0m`,cyanBrightBold:(...$)=>`\x1B[96m\x1B[1m${$.join(" ")}\x1B[0m`,redBrightBold:(...$)=>`\x1B[91m\x1B[1m${$.join(" ")}\x1B[0m`,yellowBrightBold:(...$)=>`\x1B[93m\x1B[1m${$.join(" ")}\x1B[0m`,greenBrightBold:(...$)=>`\x1B[92m\x1B[1m${$.join(" ")}\x1B[0m`,blueBrightBold:(...$)=>`\x1B[94m\x1B[1m${$.join(" ")}\x1B[0m`,magentaBrightBold:(...$)=>`\x1B[95m\x1B[1m${$.join(" ")}\x1B[0m`,whiteBrightBold:(...$)=>`\x1B[97m\x1B[1m${$.join(" ")}\x1B[0m`,grayBrightBold:(...$)=>`\x1B[90m\x1B[1m${$.join(" ")}\x1B[0m`,greyBrightBold:(...$)=>`\x1B[90m\x1B[1m${$.join(" ")}\x1B[0m`,whiteBold:(...$)=>`\x1B[37m\x1B[1m${$.join(" ")}\x1B[0m`,blackBold:(...$)=>`\x1B[30m\x1B[1m${$.join(" ")}\x1B[0m`,blackBrightBold:(...$)=>`\x1B[90m\x1B[1m${$.join(" ")}\x1B[0m`}});import{stripIndent as u2} from"common-tags";function q($,...K){return`${u2($,...K)}\n\n`}var n=L(()=>{});function S0($){return $&&$.charCodeAt!==void 0}function m($){return $!==void 0&&$!==null}var Q1=L(()=>{});import g2 from"inquirer";import{stripIndent as d2} from"common-tags";async function y($,K,Y){const{result:Z}=await g2.prompt([{type:"confirm",name:"result",message:d2`${$}`,default:K}]);if(Z)Y?.();return Z}var G1=L(()=>{});function L1($){return h1($)&&h1($.status)&&h1($.stderr)}var h1;var l1=L(()=>{h1=function($){return $!==void 0&&$!==null}});async function _1($,K=[]){try{const Y=Bun.spawnSync([$,...K.filter(m)],{stdio:["inherit","inherit","inherit"],env:process.env});if(Y.exitCode!==0){if(!_1.silent)console.error(`Error: ${$} ${K.join(" ")} failed with code: ${Y.exitCode}`),console.error(new Error().stack);return!1}}catch(Y){if(!_1.silent){if(L1(Y))console.error(`Error: ${$} ${K.join(" ")} failed with code: ${Y.status}`);else if(Y instanceof Error)console.error(Y.message);console.error(new Error().stack)}return!1}return!0}var _;var C=L(()=>{l1();Q1();_1.silent=!1;_=_1});async function P(){if(X1)return X1;if(await _("bun",["--version"]))X1=["bun","bunx"];else X1=["npm","npx"];return X1}var X1;var s=L(()=>{C();X1=null});async function R($){await new Promise((K)=>setTimeout(K,$))}var o=L(()=>{});import o2 from"fs-extra";import h from"path";async function t(){console.warn("Building Vite config using base:",W.yellowBrightBold(h.resolve("vite.config.ts")));let $=await(await import(h.resolve("vite.config.ts"))).default();const K=await o2.readJSONSync(h.resolve("tsconfig.json"));return $={...$,logLevel:"info",mode:"development",root:h.resolve("app/client"),clearScreen:!0,build:{...$.build,cssCodeSplit:!0,outDir:h.resolve("build/client"),sourcemap:!0,rollupOptions:{output:{manualChunks:void 0}},watch:{...$.build?.watch,include:[...(Array.isArray($.build?.watch?.include)?$.build?.watch?.include:[$.build?.watch?.include])||[],...K?.include?.map((Y)=>h.resolve(Y))||[],"tsconfig.json"].filter(Boolean)},emptyOutDir:!0},resolve:{alias:{config:h.resolve("app/config")}}},$}var q1=L(()=>{D()});import t2 from"deepmerge";import r2 from"fs-extra";import e2 from"path";async function g(){const $=r2.readJSONSync(e2.resolve("package.json"));return t2($.dependencies||{},$.peerDependencies||{})}var O1=L(()=>{});import $3 from"fs-extra";import K3 from"path";async function w(){return $3.readJSONSync(K3.resolve("package.json")).version||""}var v=L(()=>{});import*as y0 from"vite";import Y3 from"fs-extra";import c1 from"path";async function W1(){if(process.env.VITE_RELEASE_VERSION=process.env.VITE_RELEASE_VERSION||await w(),console.warn(W.yellowBrightBold("Starting Vite client build...")),!Y3.existsSync(c1.resolve("app/client/index.ts"))){console.warn("Tried to start development process for the app client, but no entry file was found.");return}const $=await t();$.root=c1.resolve("app/client"),$.build.outDir=c1.resolve("build/client"),$.build.rollupOptions.external=Object.keys(await g()),await y0.build($),console.warn(W.yellowBrightBold("Vite client build process started..."))}var p1=L(()=>{q1();D();O1();v()});function v0($){const K=(Y)=>(Z)=>{if($(Y,Z),Z)process.exit(1);else process.exit(0)};process.on("exit",K("exit")),process.on("SIGINT",K("SIGINT")),process.on("SIGUSR1",K("SIGUSR1")),process.on("SIGUSR2",K("SIGUSR2")),process.on("SIGTERM",K("SIGTERM")),process.on("uncaughtException",K("uncaughtException"))}var x0=L(()=>{});function n1(...$){i1.push($),Z3()}var Z3,i1,f0;var m0=L(()=>{Z3=function(){if(f0!==null)return;f0=setInterval(()=>{while(i1.length>0){const $=i1.shift();if($)console.log(...$)}},400)};i1=[],f0=null});import Q3 from"child_process";import s1 from"path";import G3 from"readline";async function z1($){console.warn("\nRunning the App server at: ",W.yellowBrightBold(s1.resolve("app/server")),"\n"),process.env.VITE_RELEASE_VERSION=process.env.VITE_RELEASE_VERSION||await w(),process.env.RESOURCE_PATH=process.env.RESOURCE_PATH||s1.resolve("build/client");const K=await P();if(K[0]!=="bun")console.error("Currently only an environment with bun installed is supported for this command.");const Y=Q3.spawn(K[0],["--watch",s1.resolve("app/server/index.ts")]);process.stdin.setRawMode?.(!0),process.stdin.resume(),process.stdin.setEncoding("utf8"),G3.emitKeypressEvents(process.stdin);let Z=!1;if(process.stdin.on("keypress",async(Q,X)=>{if(X&&X.ctrl&&X.name==="c")Y.kill(),process.exit(0);else if(X&&X.ctrl&&X.name==="d")Y.kill(),process.exit(0);else if(Q.toString()==="b"||Q.toString()==="B"){if(Z)return;Z=!0,await W1(),Z=!1}else if(Q.toString()==="q"||Q.toString()==="Q")if(Y.kill(),X.shift)process.exit(123);else process.exit(0)}),process.stdin.pipe(Y.stdin),$)$(Y);else Y.stdout.on("data",function(Q){n1(`${Q.toString().slice(0,-1)}`)}),Y.stderr.on("data",function(Q){n1(`${Q.toString().slice(0,-1)}`)});v0(async(Q,X)=>{if(Y.kill(),console.warn("EXIT BUILD SERVER"),console.warn(W.redBrightBold(Q)),X&&X instanceof Error)console.warn(W.redBrightBold(X.stack||X.message));process.exit(0)})}var a1=L(()=>{p1();D();s();x0();m0();v()});var g0={};E(g0,{default:()=>{{return u0}}});async function u0(){process.env.NODE_ENV="development",W1(),console.warn(W.yellowBrightBold("Starting dev server...")),process.env.VITE_RELEASE_VERSION=await w(),await z1()}var d0=L(()=>{p1();a1();D();v()});import A1 from"path";import X3 from"url";async function h0(){if(A1.basename(A1.resolve(o1,".."))==="dist")return A1.resolve(o1,"../../");return A1.resolve(o1,"../../../")}var o1;var l0=L(()=>{o1=X3.fileURLToPath(new URL(".",import.meta.url))});async function l($,K=[]){const Y=await P();return _(Y[0],["run",$,K.length>0&&K[0]!=="--"?"--":void 0,...K])}var B1=L(()=>{C();s()});var r1={};E(r1,{default:()=>{{return c0}}});import t1 from"path";async function c0($,K,...Y){const Z=t1.resolve(".");process.env.PROJECT_ROOT=Z,process.env.VITE_RELEASE_VERSION=await w();const Q=t1.resolve(".storybook"),X=await h0();if(process.chdir(X),K&&K.length>0)process.env.NODE_MODULES_STORIES=K.join(",");if($==="build"){if(!l("storybook",["build","-c",Q,"-o",`"${t1.resolve(Z,"storybook-static")}"`]))console.error(W.redBrightBold("Failed to build storybook"))}else if(!l("storybook",["dev","--no-version-updates","-p",process.env.PORT||"6006","-c",`"${Q}"`]))console.error(W.redBrightBold("Failed to run storybook"))}var e1=L(()=>{D();l0();B1();v()});var K0=M1((JK,i0)=>{var W3=function(){try{return p0.statSync("/.dockerenv"),!0}catch($){return!1}},z3=function(){try{return p0.readFileSync("/proc/self/cgroup","utf8").includes("docker")}catch($){return!1}},p0=import.meta.require("fs"),$0;i0.exports=()=>{if($0===void 0)$0=W3()||z3();return $0}});var a0=M1((HK,Y0)=>{var J3=import.meta.require("os"),H3=import.meta.require("fs"),n0=K0(),s0=()=>{if(process.platform!=="linux")return!1;if(J3.release().toLowerCase().includes("microsoft")){if(n0())return!1;return!0}try{return H3.readFileSync("/proc/version","utf8").toLowerCase().includes("microsoft")?!n0():!1}catch($){return!1}};if(process.env.__IS_WSL_TEST__)Y0.exports=s0;else Y0.exports=s0()});var t0=M1((FK,o0)=>{o0.exports=($,K,Y)=>{const Z=(Q)=>Object.defineProperty($,K,{value:Q,enumerable:!0,writable:!0});return Object.defineProperty($,K,{configurable:!0,enumerable:!0,get(){const Q=Y();return Z(Q),Q},set(Q){Z(Q)}}),$}});var Q$=M1((MK,Z$)=>{var q3=function(){if(Z0===void 0)Z0=_3()||L3();return Z0},K$=function($){if(typeof $==="string"||Array.isArray($))return $;const{[e0]:K}=$;if(!K)throw new Error(`${e0} is not supported`);return K},X0=function({[r]:$},{wsl:K}){if(K&&N1)return K$(K);if(!$)throw new Error(`${r} is not supported`);return K$($)},__dirname="/Users/diniden/Desktop/VoidRay/dev-ops/node-devops/node_modules/open",F3=import.meta.require("path"),M3=import.meta.require("child_process"),{promises:I1,constants:Y$}=import.meta.require("fs"),N1=a0(),L3=K0(),Q0=t0(),r0=F3.join(__dirname,"xdg-open"),{platform:r,arch:e0}=process,_3=()=>{try{return I1.statSync("/run/.containerenv"),!0}catch{return!1}},Z0,O3=(()=>{let K;return async function(){if(K)return K;const Y="/etc/wsl.conf";let Z=!1;try{await I1.access(Y,Y$.F_OK),Z=!0}catch{}if(!Z)return"/mnt/";const Q=await I1.readFile(Y,{encoding:"utf8"}),X=/(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(Q);if(!X)return"/mnt/";return K=X.groups.mountPoint.trim(),K=K.endsWith("/")?K:`${K}/`,K}})(),$$=async($,K)=>{let Y;for(let Z of $)try{return await K(Z)}catch(Q){Y=Q}throw Y},D1=async($)=>{if($={wait:!1,background:!1,newInstance:!1,allowNonzeroExitCode:!1,...$},Array.isArray($.app))return $$($.app,(z)=>D1({...$,app:z}));let{name:K,arguments:Y=[]}=$.app||{};if(Y=[...Y],Array.isArray(K))return $$(K,(z)=>D1({...$,app:{name:z,arguments:Y}}));let Z;const Q=[],X={};if(r==="darwin"){if(Z="open",$.wait)Q.push("--wait-apps");if($.background)Q.push("--background");if($.newInstance)Q.push("--new");if(K)Q.push("-a",K)}else if(r==="win32"||N1&&!q3()&&!K){const z=await O3();if(Z=N1?`${z}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`:`${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`,Q.push("-NoProfile","-NonInteractive","\u2013ExecutionPolicy","Bypass","-EncodedCommand"),!N1)X.windowsVerbatimArguments=!0;const J=["Start"];if($.wait)J.push("-Wait");if(K){if(J.push(`"\`"${K}\`""`,"-ArgumentList"),$.target)Y.unshift($.target)}else if($.target)J.push(`"${$.target}"`);if(Y.length>0)Y=Y.map((M)=>`"\`"${M}\`""`),J.push(Y.join(","));$.target=Buffer.from(J.join(" "),"utf16le").toString("base64")}else{if(K)Z=K;else{const z=!__dirname||__dirname==="/";let J=!1;try{await I1.access(r0,Y$.X_OK),J=!0}catch{}Z=process.versions.electron||r==="android"||z||!J?"xdg-open":r0}if(Y.length>0)Q.push(...Y);if(!$.wait)X.stdio="ignore",X.detached=!0}if($.target)Q.push($.target);if(r==="darwin"&&Y.length>0)Q.push("--args",...Y);const G=M3.spawn(Z,Q,X);if($.wait)return new Promise((z,J)=>{G.once("error",J),G.once("close",(M)=>{if(!$.allowNonzeroExitCode&&M>0){J(new Error(`Exited with code ${M}`));return}z(G)})});return G.unref(),G},G0=($,K)=>{if(typeof $!=="string")throw new TypeError("Expected a `target`");return D1({...K,target:$})},A3=($,K)=>{if(typeof $!=="string")throw new TypeError("Expected a `name`");const{arguments:Y=[]}=K||{};if(Y!==void 0&&Y!==null&&!Array.isArray(Y))throw new TypeError("Expected `appArguments` as Array type");return D1({...K,app:{name:$,arguments:Y}})},T1={};Q0(T1,"chrome",()=>X0({darwin:"google chrome",win32:"chrome",linux:["google-chrome","google-chrome-stable","chromium"]},{wsl:{ia32:"/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",x64:["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe","/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]}}));Q0(T1,"firefox",()=>X0({darwin:"firefox",win32:"C:\\Program Files\\Mozilla Firefox\\firefox.exe",linux:"firefox"},{wsl:"/mnt/c/Program Files/Mozilla Firefox/firefox.exe"}));Q0(T1,"edge",()=>X0({darwin:"microsoft edge",win32:"msedge",linux:["microsoft-edge","microsoft-edge-dev"]},{wsl:"/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"}));G0.apps=T1;G0.openApp=A3;Z$.exports=G0});async function I($,K=[]){try{const Y=Bun.spawnSync([$,...K.filter(m)],{stdio:["inherit","pipe","pipe"],env:process.env});if(Y.exitCode!==0)return console.error(`Error: ${$} ${K.join(" ")} failed with code: ${Y.exitCode}`),console.error(new Error().stack),null;return(Y.stdout||"").toString()}catch(Y){if(L1(Y))console.error(`Error: ${$} ${K.join(" ")} failed with code: ${Y.status}`);else if(Y instanceof Error)console.error(Y.message);return console.error(new Error().stack),null}}var c=L(()=>{l1();Q1()});function G$({template:$,options:K,required:Y,doubleCurlyBrackets:Z,onError:Q,onToken:X}){const G=new Map,z=new Map,J=new Map,M=new Map;let H=/\$\{([^\}]*)\}/g;if(Z)H=/\$\{\{([^\}]*)\}\}/g;const B=$.replace(H,(O,F)=>{let U="";if(M.set(F,(M.get(F)||0)+1),F in K){G.set(F,(G.get(F)||0)+1);const T0=K[F];if(T0!==void 0)U=T0}else z.set(F,(z.get(F)||0)+1);if(X){if(U=X(F,U),U!==F)G.set(F,(G.get(F)||0)+1),z.delete(F)}return U});Object.keys(K).forEach((O)=>{if(!G.get(O))J.set(O,(J.get(O)||0)+1)});const N={resolvedtemplateOptions:G,template:B,templateProvidedOptions:M,unresolvedProvidedOptions:J,unresolvedTemplateOptions:z};if(Y)Y.values.forEach((O)=>{if(N.unresolvedProvidedOptions.get(O)){const F=`${Y.name}: Could not resolve all the required inputs. Input: ${O}`;if(Q)Q(F);else console.error(F)}else if(N.unresolvedTemplateOptions.get(O)){const F=`${Y.name}: A required option was not provided in the options parameter. Option: ${O}`;if(Q)Q(F);else console.error(F)}else if(!N.resolvedtemplateOptions.get(O)){const F=`${Y.name}: A required option was not provided in the options parameter. Option: ${O}`;if(Q)Q(F);else console.error(F)}});return N}var X$=L(()=>{});var _$={};E(_$,{default:()=>{{return L$}}});import U1 from"fs-extra";import W$ from"hostile";import M$ from"path";import z$ from"valid-url";async function N3(){const K=U1.readJSONSync(M$.resolve("package.json")).hosts;if(!K)return;const Y=Object.keys(K);let Z=await J$(W$,"get",!1);const Q=[];console.warn(W.yellow("Updating hosts file..."));for(let G of Y)try{if(!Z.find((z)=>z[0]===G&&z[1]===K[G]))Q.push([G,K[G]])}catch(z){if(z instanceof Error)console.warn(W.red(z.message))}if(Q.length>0){console.warn(W.yellow("Adding hosts (You may be prompted for administrator password):\n\t",Q.map((z)=>`${z[0]} => ${z[1]}`).join("\n\t"))),await _("sudo",["echo","Granted sudo access to update hosts file."]);const G=await I("stat",["-f","%p","/etc/hosts"]).toString();await _("sudo",["chmod","666","/etc/hosts"]);for(let z of Q)U1.appendFileSync("/etc/hosts",`${z[0]} ${z[1]}`);U1.appendFileSync("/etc/hosts","\n"),await _("sudo",["chmod",G.substring(G.length-4).trim(),"/etc/hosts"])}await R(500),console.warn(W.yellow("Verifying hosts file...")),Z=await J$(W$,"get",!1);let X=!1;if(Q.forEach(([G,z])=>{if(!Z.find((J)=>J[0]===G&&J[1]===K[G]))X=!0,console.warn(W.redBright(`Failed to add host: ${W.yellowBright(G)} => ${W.yellowBright(z)}`))}),X)console.warn(W.red(q`
        *************************************************************************
        * Some hosts specified in the package.json were not able to be written  *
        * to the hosts file for the system. You can amend this by editing the   *
        * file yourself, or by trying to run this script again as an admin.     *
        *************************************************************************
      `))}async function L$($,K){const Z=U1.readJSONSync(M$.resolve("package.json"))?.url||{},Q=K?.reduce((G,z,J)=>{return G[`${J+1}`]=z,G},{})||{};if(!$||$.length<=0){console.warn(q`
      Available URLs:
        ${W.cyanBrightBold(Object.keys(Z).join("\n        "))}
    `);return}await N3();const X={...process.env,...Q};if(Array.isArray($))$.forEach((G)=>{H$(Z,G,X)});else H$(Z,$,X)}var F$,B3,J$,H$;var q$=L(()=>{F$=f2(Q$(),1);D();n();C();c();X$();o();B3=function($){return $&&typeof $==="function"},J$=function($,K,...Y){return new Promise((Z,Q)=>{const X=$[K];if(!B3(X)){Q(new Error(`${String(K)} is not a function`));return}X(...Y,(G,z)=>{if(G)console.warn(G),Q(G),process.exit(1);else Z(z||void 0)})})};H$=function($,K,Y){let Z=K;if(z$.isWebUri(K))Z=K;else if($[K])Z=$[K];const Q=G$({options:Y,template:Z});if(Q.unresolvedTemplateOptions.size>0)throw console.warn(W.red(q`
          You must specify these env variables for this URL to work:
          ${Array.from(Q.unresolvedTemplateOptions.keys()).join("\n\t")}
        `)),new Error("Missing env configuration for URL");if(Z=Q.template,z$.isWebUri(Z))console.warn("Navigating to:",W.cyanBrightBold(Z)),F$.default(Z);else console.warn("Can not open invalid URL:",W.redBrightBold(Z))}});import I3 from"child_process";async function e(){try{I3.execSync("git status --porcelain=v1 2>/dev/null | wc -l | grep 0",{env:process.env})}catch($){return!0}return!1}var w1=L(()=>{});async function V1($){if($){if(!await y(`
      Would you like to return back to development?
      Runs the following:
        git fetch
        git checkout dev
        git reset --hard origin/dev
    `))return}if(await e())return console.error("Can not return to dev branch as changes are present on the current branch."),!1;let K=!1;if(!await _("git",["fetch"]))K=!0;if(!await _("git",["checkout","dev"]))K=!0;if(!await _("git",["reset","--hard","origin/dev"]))K=!0;if(K)return console.error("Could not return to dev branch."),!1;return!0}var W0=L(()=>{C();w1();G1()});import T from"fs-extra";import D3 from"ignore";import A from"path";async function T3(){const $=await g();console.warn("Building full distribution...");let K=await Bun.build({entrypoints:[A.resolve("./bin/main.ts")],target:"bun",external:Object.keys($),minify:!0});for(let Y of K.outputs)console.warn("Writing bin bundle resource:",W.cyanBrightBold(Y.path)),await Bun.write(A.resolve("./dist/bin",Y.path),Y);console.warn("Building gimped distribution..."),K=await Bun.build({entrypoints:[A.resolve("./bin/main-gimp.ts")],target:"node",external:Object.keys($),minify:!0});for(let Y of K.outputs)console.warn("Writing bin bundle resource:",W.cyanBrightBold(Y.path)),await Bun.write(A.resolve("./dist/bin",Y.path),Y);console.warn("Copying entry cross-platform distribution..."),T.copyFileSync(A.resolve("./bin/main-entry.js"),A.resolve("./dist/bin/main-entry.js"))}async function U3(){if(!T.existsSync(A.resolve("./bin/shim")))console.error("No shim distribution files found to be built");if(T.existsSync(A.resolve("./shim")))T.removeSync(A.resolve("./shim"));const $=await g();console.warn("Building shim distribution...");const K=await Bun.build({entrypoints:[A.resolve("./bin/shim/index.ts")],target:"node",external:Object.keys($),minify:!0});for(let Z of K.outputs)console.warn("Writing shim bundle resource:",W.cyanBrightBold(Z.path)),await Bun.write(A.resolve("./shim/src/bin/shim",Z.path),Z);T.writeFileSync(A.resolve("./shim/index.js"),'export * from "./src/bin/shim/index.js";\n',{encoding:"utf-8"}),T.writeFileSync(A.resolve("./shim/index.d.ts"),'export * from "./src/bin/shim/index.d.ts";\n',{encoding:"utf-8"});const Y=T.readJSONSync(A.resolve("tsconfig.json"));if(Y.exclude=Y.exclude||[],Y.exclude.push("./bin/lib/**"),Y.include=["./bin/shim"],T.writeJSONSync(A.resolve("tsconfig.temp.json"),Y),await R(500),!_("tsc",["-d","--emitDeclarationOnly","--pretty","--outDir",A.resolve("./shim/src/bin"),"--project",A.resolve("tsconfig.temp.json")]))console.warn("Failed to compile type declarations for the shim files."),T.removeSync(A.resolve("tsconfig.temp.json")),process.exit(1);T.removeSync(A.resolve("tsconfig.temp.json"))}async function w3(){console.warn(W.yellowBright("Copying template files for bin distribution"));const $=A.resolve(__dirname,"../../template"),K=A.resolve("./dist/bin/template");T.copySync($,K);const Y=T.readdirSync(K).map((Q)=>A.resolve(K,Q,"index.ts")).filter((Q)=>{if(T.existsSync(Q))return!0}),Z=await g();for(let Q of Y){const X=await Bun.build({entrypoints:[Q],target:"bun",external:Object.keys(Z),minify:!0});for(let G of X.outputs)console.warn("Writing template entry file:",W.cyanBrightBold(A.relative(K,A.resolve(A.dirname(Q),G.path)))),await Bun.write(A.resolve(A.dirname(Q),G.path),G)}}async function V3(){console.warn(W.yellowBright("Copying entry shell script for bin distribution")),T.copySync(A.resolve("./bin/main-entry.sh"),A.resolve("./dist/bin/main-entry.sh")),T.copySync(A.resolve("./bin/main-entry.ps1"),A.resolve("./dist/bin/main-entry.ps1"))}async function A$(){if(console.warn(W.cyanBright("Building bin commands for the distribution.")),!T.existsSync(A.resolve("./bin/main.ts"))||!T.existsSync(A.resolve("./bin/main-entry.sh"))||z0.ignores("bin")){console.warn(`Tried to make a release for the bin commands, but no bin/main.ts or bin/main.sh entry file was found. (or was gitignored):\n\t${A.resolve("./bin/main.ts")}\n\t${A.resolve("./bin/main.sh")}`);return}T.ensureDirSync(A.resolve("./dist")),T.ensureDirSync(A.resolve("./dist/bin/template")),await T3(),await U3(),await w3(),await V3()}var __dirname,O$,z0;var B$=L(()=>{D();C();O1();o();__dirname="/Users/diniden/Desktop/VoidRay/dev-ops/node-devops/bin/lib/build/bin",O$=A.resolve(".gitignore"),z0=D3.default();if(T.existsSync(O$))z0=z0.add(T.readFileSync(O$).toString())});import N$ from"fs";import I$ from"path";function D$($){return{name:"vite-devops-string-replace-plugin",enforce:"pre",load(K){const Y=I$.resolve(K),Z=[".ts",".js",".tsx",".jsx"];if(N$.existsSync(Y)&&Z.includes(I$.extname(Y))&&!Y.includes("node_modules")&&!Y.includes("\0")){let Q=N$.readFileSync(Y,{encoding:"utf-8"});return $.forEach((X)=>{Q=Q.replace(X.from,X.to)}),Q}}}}var T$=L(()=>{});import b from"fs-extra";import j from"path";function U$($){const K=process.env.PROJECT_ROOT||".",Y=j.resolve(K,"app/config");if(!b.existsSync(Y)){console.warn(`viteDevopsAppConfigPlugin: ${W.cyanBrightBold("No app/config folder found.")}`);return}try{const Z=b.readdirSync(Y).filter((H)=>{return b.statSync(j.join(Y,H)).isDirectory()}),Q=Z.map((H)=>j.join(Y,H)),G=Z.map((H,B)=>{if(!$)if(b.existsSync(j.join(Q[B],`${H}.local`))||b.existsSync(j.join(Q[B],`${H}.local.js`))||b.existsSync(j.join(Q[B],`${H}.local.ts`))||b.existsSync(j.join(Q[B],`${H}.local.tsx`))||b.existsSync(j.join(Q[B],`${H}.local.jsx`)))return[{from:`"config/${H}/${H}"`,to:`"config/${H}/${H}.local"`},{from:`"config/${H}/${H}.js"`,to:`"config/${H}/${H}.local.js"`},{from:`"config/${H}/${H}.ts"`,to:`"config/${H}/${H}.local.ts"`}];else return[];return[{from:`"config/${H}/${H}"`,to:`"config/${H}/${H}.${$}"`},{from:`"config/${H}/${H}.js"`,to:`"config/${H}/${H}.${$}.js"`},{from:`"config/${H}/${H}.ts"`,to:`"config/${H}/${H}.${$}.ts"`}]}).reduce((H,B)=>H.concat(B),[]),M=[...!$&&(b.existsSync(j.join(Y,"env.local"))||b.existsSync(j.join(Y,"env.local.js"))||b.existsSync(j.join(Y,"env.local.ts"))||b.existsSync(j.join(Y,"env.local.tsx"))||b.existsSync(j.join(Y,"env.local.jsx")))?[{from:'"config/env"',to:'"config/env.local"'},{from:'"config/env.js"',to:'"config/env.local.js"'},{from:'"config/env.ts"',to:'"config/env.local.ts"'}]:$?[{from:'"config/env"',to:`"config/env.${$}"`},{from:'"config/env.js"',to:`"config/env.${$}.js"`},{from:'"config/env.ts"',to:`"config/env.${$}.ts"`}]:[],...G];if(M.length>0)console.warn(`

  ${W.yellowBrightBold("Using the following mappings for app config:")}

  \t${W.cyanBrightBold(M.map((H)=>`\n  ${H.from} => ${H.to}`).join("\n\t"))}

      `);return D$(M)}catch(Z){console.error(Z),console.error(W.redBrightBold(`
      App config plugin failed to load. The default config paths will be used
      and any specific environment requested will be ignored.
    `))}}var w$=L(()=>{D();T$()});import*as C$ from"vite";import C1 from"fs-extra";import C3 from"ignore";import $1 from"path";async function S$($){if(console.warn(W.cyanBright("Building client files for the distribution.")),process.env.VITE_RELEASE_VERSION=process.env.VITE_RELEASE_VERSION||await w(),process.env.FORCE_BUILD!=="true"){if(!C1.existsSync($1.resolve("app/client"))||J0.ignores("app/client")){console.error(`Tried to make a release for the web app client, but no app/client entry file was found. (or was gitignored):\n\t${$1.resolve("app/client")}`);return}}const K="development";process.env.NODE_ENV="production",console.warn(`Releasing ${W.yellowBrightBold("app/client")} for Environment:`,W.cyanBrightBold($)),process.env.BUILD_ENV=$;const Y=await t();if(Y.plugins=[U$($),...Y.plugins||[]],Y.logLevel="warn",Y.mode="production",Y.root=$1.resolve("app/client"),Y.build.outDir=$1.resolve("dist/app/client",$),Y.build.watch=void 0,Y.build.rollupOptions.output={dir:Y.build.outDir,entryFileNames:"index.js",chunkFileNames:"index.js",manualChunks:void 0},await C$.build(Y),process.env.NODE_ENV=K,!C1.existsSync($1.resolve(`dist/app/client/${$}/index.js`)))console.error("\n\nFailed to create Client output bundle. Exiting process...\n\n"),process.exit(1)}var V$,J0;var E$=L(()=>{q1();D();v();w$();V$=$1.resolve(".gitignore"),J0=C3.default();if(C1.existsSync(V$))J0=J0.add(C1.readFileSync(V$).toString())});async function K1($=[]){const K=await P();if(K1.optimize){if(K[1]==="bunx")return _(K[1],["--bun",...$])}return _(K[1],[...$])}var H0=L(()=>{C();s();K1.optimize=!0});import S1 from"fs-extra";import J1 from"path";async function E1(){if(!S1.existsSync(J1.resolve("ui")))return;S1.ensureDir(J1.resolve("dist/ui")),console.warn(W.yellowBrightBold("Generating .d.ts files...")),K1(["tsc","--emitDeclarationOnly","--declaration","--outDir","dist/types","--project",J1.resolve("tsconfig.json")]);const $=S1.readdirSync(J1.resolve("dist/types"));for(let K of $){if(K==="ui"||K==="util")continue;console.warn(W.yellowBright(`Removing types for folder: ${K}`)),S1.removeSync(J1.resolve("dist/types",K))}}var F0=L(()=>{D();H0()});import S3 from"fs-extra";import E3 from"path";async function b$(){return S3.readJSONSync(E3.resolve("package.json")).name||""}var j$=L(()=>{});import*as P$ from"vite";import b1 from"fs";import b3 from"ignore";import d from"path";async function k$(){if(console.warn(W.cyanBright("Copying ui files for the distribution.")),process.env.VITE_RELEASE_VERSION=process.env.VITE_RELEASE_VERSION||await w(),!process.env.FORCE_BUILD){if(!b1.existsSync(d.resolve("ui"))||M0.ignores("ui")){console.error(`"No library project found (or was gitignored) for bundling release at:\n\t${d.resolve("ui")}`);return}}if(console.warn(W.yellowBrightBold("Starting Vite client build...")),!b1.existsSync(d.resolve("ui/index.ts"))){console.error("The UI folder project has no index.ts entry point to create the library.");return}await E1(),console.warn(W.yellowBrightBold("Building library bundle..."));const $=await t();$.logLevel="warn",$.root=d.resolve("ui"),$.build.lib={entry:d.resolve("ui/index.ts"),name:(await b$()).split("@").join("").split("/").join("_"),fileName:"index"},$.mode="production",$.root=d.resolve("app/client"),$.build.outDir=d.resolve("dist/ui"),$.build.watch=void 0,$.build.rollupOptions.output={dir:$.build.outDir,entryFileNames:"index.js",chunkFileNames:"index.js",manualChunks:void 0};const K=Object.keys(await g());console.warn("Externalized Libraries that will not be included in the bundle:",K),$.build.rollupOptions={...$.build.rollupOptions,external:K},await P$.build($)}var R$,M0;var y$=L(()=>{q1();D();F0();O1();j$();v();R$=d.resolve(".gitignore"),M0=b3.default();if(b1.existsSync(R$))M0=M0.add(b1.readFileSync(R$).toString())});import p from"fs-extra";import x from"path";async function v$(){process.env.VITE_RELEASE_VERSION=process.env.VITE_RELEASE_VERSION||await w(),console.warn(W.cyanBright("Copying story files for the distribution."));const $=x.resolve("dist/stories"),K=x.resolve("ui/stories"),Y=x.resolve("dist");if(!p.existsSync(K)){console.error(`Could not find stories directory:\n\t${K}`);return}p.ensureDirSync($),p.copySync(K,$);const Z=x.resolve("package.json"),X={name:p.readJSONSync(Z).name||"unknown",private:!0,type:"module",main:"./ui/index.js",types:"./types/ui/index.d.ts",dependencies:{},repository:{},scripts:{},devDependencies:{}};console.warn("Writing distribution package.json:",x.resolve(Y,"package.json")),p.writeJSONSync(x.resolve(Y,"package.json"),X),await R(500),p.ensureDirSync(x.resolve(Y,"components")),X.main="../ui/index.js",X.types="../types/ui/index.d.ts",console.warn("Writing distribution package.json:",x.resolve(Y,"components/package.json")),p.writeJSONSync(x.resolve(Y,"components/package.json"),X),await R(500),console.warn("Finished copying stories.")}var x$=L(()=>{D();v();o()});var f$={};E(f$,{default:()=>{{return R1}}});import j1 from"fs-extra";import Y1 from"path";async function j3(){if(process.env.QUICK_BUILD==="true")return;if(await l("release",["view"]),!await y("\nShould the release continue being made?"))await V1(!0),process.exit(1)}async function R3(){console.warn("Gathering build targets from:",W.yellowBright(Y1.resolve("build.conf.js")));const $=(await import(Y1.resolve("build.conf.js"))).BUILD_TARGETS;if(process.env.NODE_ENV="production",console.warn("Building environments",W.redBrightBold(JSON.stringify($))),!Array.isArray($))console.error("build.conf.js must be an array of string values"),process.exit(1);for(let K of $)await S$(K);await k$(),await v$(),await A$()}async function P3(){try{j1.removeSync(Y1.resolve("dist"))}catch($){console.warn("No dist folder to clean out.")}j1.ensureDirSync(Y1.resolve("dist"))}async function k3(){try{j1.removeSync(Y1.resolve("dist/test"))}catch($){console.warn("No test folder to clean out")}try{j1.removeSync(Y1.resolve("dist/unit-test"))}catch($){console.warn("No unit-test folder to clean out")}}async function R1(){console.warn("Validating the release..."),await j3(),console.warn("Clear previous build..."),await P3(),console.warn("Bundling project..."),await R3(),console.warn("Final cleanup..."),await k3(),console.warn("Release Build complete!")}var L0=L(()=>{D();B1();W0();G1();B$();E$();y$();x$()});var h$={};E(h$,{default:()=>{{return k1}}});import g$ from"fs-extra";import y3 from"lodash/groupBy.js";import P1 from"path";import v3 from"lodash/uniq.js";import x3 from"lodash/upperFirst.js";import{compare as f3,inc as m3} from"semver";async function l3($){console.warn("Building release notes..."),console.warn("fetching tags...");const K=await I("git",["tag","--list"]);if(K===null)console.error("Could not get git tags"),process.exit(1);const Y=K.trim().split("\n").sort(f3),Z=Y[(Y.includes($)?Y.indexOf($):Y.length)-1];console.warn("fetching version hash...");const Q=await I("git",["rev-list","-1",`${$}`]);if(Q===null)console.error("Couldn't get current version hash"),process.exit(1);const X=Q.trim();console.warn("fetching previous version hash...");let G=await I("git",["rev-list","-1",`${Z}`]);if(G===null){if(G=await I("git",["rev-list","--max-parents=0","HEAD"]),G===null)console.error("Couldn't get previous version hash"),process.exit(1)}const z=G.trim();console.warn("fetching logs...");const J=await I("git",["log","--pretty=%B",`${z}...${X}`]);if(J===null)console.error("Couldn't get logs"),process.exit(1);const M=J.split("\n").map((N)=>{const[,O="",F=""]=N.match(/^\s*(\w+?)\s*:\s*(.*)\s*$/)||[];return{tag:d$[O.toLowerCase()],message:x3(F)}}).filter((N)=>N.tag),H=y3(M,"tag"),B=d3.filter((N)=>H[N]).map((N)=>{const O=H[N];return`## ${N.replace(/(\w)/,(F)=>F.toUpperCase())}\n\n${O.map(({tag:F,message:U})=>`- [\`${F.toUpperCase()}\`]: ${U}`).join("\n")}`}).join("\n\n");return console.warn("New release notes completed"),B}async function k1($={}){if(console.warn("Generating Release Notes..."),await I("git",["fetch","--tags"])===null)console.error("Couldn't fetch tags"),process.exit(1);const Y=m$(P1.resolve("package.json")),{version:Z="0.0.1"}=Y;console.warn("Current Project version:",{currentVersion:Z});const Q=await l3("HEAD"),X=h3(Q),G=X&&m3(Z,X);if(!G)console.error("Unable to determine next version",{currentVersion:Z}),process.exit(1);if($.tag){if(console.warn("Creating the new tag..."),await I("git",["tag","-a",G,"-m",`Release ${G}`])===null)console.error("Couldn't create tag"),process.exit(1)}if($.updatePackage){console.warn("Updating the package.json...");const J=m$(P1.resolve("package.json"));J.version=G,u$(P1.resolve("package.json"),`${JSON.stringify(J,null,"  ")}\n`)}const z=`## ${G}\n\n${Q}`;if(!Q.trim()&&$.errorOnEmpty)throw new Error("No notes were generated as no semver style messages were found");if($.file){console.warn("Writing the release notes to file:",$.file);const J=P1.resolve($.file),M=u3(J)?g3(J):"";u$(J,`${`${z}\n\n${M}`.trim()}\n`);for(let B=0;B<=100;++B){if(g$.existsSync(J))break;if(B===100)console.warn("Release notes file was not created in time for the final release commit:",W.redBrightBold(J)),process.exit(1)}if(console.warn("Adding fragments to git..."),await I("git",["add","-A"])===null)console.warn("Could not ensure all fragments are added for the next commit."),process.exit(1);if(console.warn("Committing to git..."),await I("git",["commit","-am",`Release ${G}`])===null)console.error("Couldn't commit changes"),process.exit(1);console.warn(`\n\n${W.cyan(z)}\n\n`)}else console.warn(`\n\n${W.cyan(z)}\n\n`);process.env.VITE_RELEASE_VERSION=G}var h3,u3,g3,m$,u$,d$,d3;var _0=L(()=>{D();c();h3=function($){const K=$.toLowerCase().split("\n").map((Y)=>(Y.match(/## (\w+)/)||[])[1]).filter(Boolean);if(K.includes("breaking"))return"major";if(K.includes("added"))return"minor";return"patch"};({existsSync:u3,readFileSync:g3,readJSONSync:m$,writeFileSync:u$}=g$),d$={breaking:"breaking",feat:"added",feature:"added",added:"added",fix:"fixed",fixed:"fixed",hotfix:"fixed",task:"task"},d3=v3(Object.values(d$))});async function y1($){return _("git",["ls-remote",$])}var q0=L(()=>{C()});async function l$($){const K=await I("git",["remote","-v"]);if(K===null)console.warn("Could not list remotes for the git project."),process.exit(1);const Y=K.split(/\r?\n/g),Z=Y.find((X)=>X.indexOf($)>=0);if(!Z)console.warn(q`
      You MUST have a remote named ${$} which points to the repository you
      wish to deploy to.

      ${Y.join("\n")}
    `),process.exit(1);const Q=Z.split(/\s+/g)[1];if(!y1(Q))console.warn(`
      You do not seem to have access to the repo listed in the package json of
      this project. Please ensure you have write access to the repo:
      ${Q}
      and then try to run the release again.
    `),process.exit(1)}var c$=L(()=>{n();c();q0()});async function p$(){const $=await I("git",["rev-parse","--abbrev-ref","HEAD"]);if($===null){console.error("Failed to determine current branch.");return}return $.trim()||void 0}var i$=L(()=>{c()});var n$;var s$=L(()=>{c();i$();n$=async($,K)=>{const Y=await p$();if(!Y)return console.warn("Could not determine current branch."),!1;if(await I("git",["checkout",`${K}`])===null)return console.warn(`Could not checkout branch ${K}`),!1;if(await I("git",["reset","--hard",`${$}/${K}`])===null){if(console.warn(`Could not reset branch ${K}`),await I("git",["checkout",`${Y}`]))console.warn(`Could not return to original branch ${Y}`);return!1}if(await I("git",["checkout",`${Y}`])===null)return console.warn(`Could not return to original branch ${Y}`),!1;return!0}});import c3 from"fs-extra";import p3 from"path";async function a$(){return c3.readJSONSync(p3.resolve("package.json")).repository||{}}var o$=L(()=>{});var e$={};E(e$,{default:()=>{{return r$}}});import v1 from"fs-extra";import x1 from"path";async function i3(){const $=await a$(),K=$.url;if(!$||!($.type!=="gitlab"||$.type!=="git"||$.type!=="bitbucket"||$.type!=="stash"))console.warn(`
      You MUST have a repository specified in your package json to use the
      release script. It must be of 'type: git' and have a valid ssh url to
      your git repo.

      Additionally, you MUST have a remote configured for your project of
      'origin' that matches the repo url listed in your package.json.

      Thus: "git remote -v" SHOULD output a line with
      origin <url in your package json repository field> (push)
    `),process.exit(1);const Y=await I("git",["remote","-v"]);if(Y===null)console.warn("Could not list remotes for the git project."),process.exit(1);const Z=Y.split(/\r?\n/g);if(!Z.find((X)=>X.indexOf(i)>=0&&X.indexOf(K)>=0))console.warn("Could not match package json repository to an origin remote in git CLI",{remoteListProcess:Y,remotes:Z,ENSURE_REMOTE:i,ENSURE_REMOTE_PROJECT:K}),process.exit(1);if(!y1(K))console.warn(`
      You do not seem to have access to the repo listed in the package json of
      this project. Please ensure you have write access to the repo:
      ${K}
      and then try to run the release again.
    `),process.exit(1);if(await e())console.error("You have uncommitted changes or the current state of the project can not be determined. Please commit or stash them before continuing."),process.exit(1);console.warn("Repository validation complete")}async function n3(){if(!await await _("git",["checkout","release"])){if(!await _("git",["checkout","-b","release"]))console.warn("Could not switch to the release branch. Make sure the branch exists locally."),process.exit(1)}if(!await _("git",["fetch",`${i}`]))console.warn("Could not fetch from remote servers."),process.exit(1);if(!await _("git",["reset","--hard",`${i}/dev`]))console.warn("Could not reset branch to dev"),process.exit(1);console.warn("Checked out release branch and updated to dev")}async function a3($){const K=await w();if(!await _("git",["add","-A"]))console.warn("Could not ensure all fragments are added for the next commit."),process.exit(1);await k1({file:"RELEASE_NOTES.md",updatePackage:!0});const Y=await w();if(K===Y)console.warn(`
      The release script did not detect any changes for a release. If you find
      this to be in error or you want to force a new release. Make some commits
      with proper release note formatted messages to trigger a release.
    `),process.exit(1);if($){if(s3()!=="patch")console.error(`
        Cannot create a release for an alternate branch that is not a simple
        patch. Features and breaking changes can ONLY be made on the main branch of
        development.
      `),process.exit(1)}const Z=await I("git",["log","-1","--pretty=%B"]);if(Z===null)console.warn("Could not read the last commit version information"),process.exit(1);const Q=(Z.trim().toLowerCase().split("release ")[1]||"").trim();if(!Q)console.warn("Could not determine release version from the last commit:\n\n",Z.toString(),"\n\n"),process.exit(1);if(v1.existsSync(x1.resolve("ui/release.json"))){try{const X=v1.readJSONSync(x1.resolve("ui/release.json"));X.version=Q,v1.writeJSONSync(x1.resolve("ui/release.json"),X)}catch(X){console.warn("Could not update the release.json file with current library version."),process.exit(1)}if(!await _("git",["add","-A"]))console.warn("Could not ensure the release json was updated for the new version."),process.exit(1);if(!await _("git",["commit","--amend","--no-edit"]))console.warn("Could not amend the release commit to include the release json file."),process.exit(1)}if(Q.includes('"'))console.warn("The update version generated is invalid as it contains invalid characters",{version:Q}),process.exit(1);return console.warn("Updating version to",{version:Q}),Q}async function o3($){if(!await _("git",["tag","-a",$,"-m",`Release ${$}`]))console.warn("Could not make tag for git commit"),process.exit(1)}async function t$($,K,Y,Z,Q){if(!await _("git",["push",Q?"-f":void 0,$,`${Y}:${Z}`]))console.warn(`Could not push release commit to ${$}`),process.exit(1);if(!await _("git",["push",$,K]))console.warn("Could not push tag to the remote repository"),process.exit(1)}async function t3($,K){if($&&$.length>0){if(!await y(q`
        The build and release was successful, would you like to release to the
        specified additional remotes?

        ${W.cyanBrightBold($.join("\n"))}
      `))return}if(!await _("git",["fetch",i]))console.warn("Could not fetch from remote servers."),process.exit(1);for(let Y of $){const[Z,Q,X,G]=Y.split(":");await l$(Z),await n$(i,Q||"master"),await t$(Z,K,Q||"master",X||"master",G==="force")}}async function r3($){process.env.NODE_ENV="production",await i3(),await n3(),await R1();const K=await a3();if(await o3(K),await t$(i,K,"release","release",!0),await y("Would you like to run pr release?"))await l("pr",["release"]);await t3($,K),await V1(!0)}async function r$($){console.warn("Executing release script"),r3($)}var s3,i;var $2=L(()=>{L0();_0();D();n();B1();C();c();q0();c$();w1();W0();s$();G1();o$();v();s3=function(){try{const K=v1.readFileSync(x1.resolve("RELEASE_NOTES.md"),"utf8").toLowerCase().split("\n").map((Y)=>(Y.match(/## (\w+)/)||[])[1]).filter(Boolean);if(K.includes("breaking"))return"major";if(K.includes("added"))return"minor";return"patch"}catch($){console.error("Could not determine release type after release was created"),process.exit(1)}};i="origin"});var Y2={};E(Y2,{default:()=>{{return K2}}});async function K2(){await E1()}var Z2=L(()=>{F0()});var O0={};E(O0,{default:()=>{{return G2}}});import f from"fs-extra";import e3 from"ignore";import S from"path";async function $4($){const K=f.readJSONSync(S.resolve("tsconfig.json"));if(K.exclude=K.exclude||[],K.include=(K?.include||[]).filter((Z)=>!f1.ignores(S.relative("./",Z))),f.writeJSONSync(S.resolve("tsconfig.temp.json"),K),await R(500),$==="watch"){const Z=async()=>{console.warn("Exit TS process");try{f.removeSync(S.resolve("tsconfig.temp.json"))}catch(Q){}process.exit(0)};process.on("exit",Z),process.on("SIGINT",Z),process.on("SIGUSR1",Z),process.on("SIGUSR2",Z),process.on("SIGTERM",Z),process.on("uncaughtException",Z)}if(!_("tsc",["-d",$==="watch"?"--watch":"","--incremental","--noemit","--pretty","--tsBuildInfoFile",S.resolve("node_modules/.cache/tsc/tsc.tsbuildinfo"),"--outDir",S.resolve("dist"),"--project",S.resolve("tsconfig.temp.json")]))console.warn("Failed to compile type declarations"),f.removeSync(S.resolve("tsconfig.temp.json")),process.exit(1);const Y=(K?.include||[]).filter((Z)=>!f1.ignores(S.relative("./",Z))).map((Z)=>S.resolve(Z)).filter((Z)=>f.existsSync(Z)&&!Z.includes("node_modules"));if(Y.length>0){if(!_("eslint",[...Y,"-c",S.resolve(".eslintrc"),"--ext",".ts","--ext",".tsx"]))console.warn("Failed eslint checks."),f.removeSync(S.resolve("tsconfig.temp.json")),process.exit(1)}f.removeSync(S.resolve("tsconfig.temp.json"))}async function G2($){await $4($)}var Q2,f1;var A0=L(()=>{C();o();Q2=S.resolve(".gitignore"),f1=e3.default();if(f.existsSync(Q2))f1=f1.add(f.readFileSync(Q2).toString())});var W2={};E(W2,{default:()=>{{return X2}}});async function X2(){console.warn(W.yellowBrightBold("Starting server...")),await z1()}var z2=L(()=>{a1();D()});var L2={};E(L2,{default:()=>{{return M2}}});import K4 from"fs-extra";import B0 from"path";async function F2($){if(!K4.existsSync($))return console.warn("Attempted to start a server but no server distribution was found at",$),!1;return await _("bun",[`${$}`]),!0}async function J2(){const $=B0.resolve("docs/index.js");return await F2($)}async function H2(){process.env.RESOURCE_PATH=B0.resolve("dist/app/client");const $=B0.resolve("dist/app/server/index.js");return await F2($)}async function M2($,K){const{PORT:Y="80"}=process.env;process.env.PORT=Y;let Z=!1;switch($){case"app":Z=await H2();break;case"devops":Z=await J2();break;default:if($)console.warn("Invalid target for start script specified",$);break}if(!Z){if(Z=await H2(),Z)return;if(Z=await J2(),Z)return}}var _2=L(()=>{C()});import Y4 from"fs-extra";import N0 from"path";async function q2(){const $=N0.resolve("tsconfig.json");if(!Y4.existsSync($))throw new Error("Target project does not have a TSConfig");const K=Boolean(process.env.DEBUG),Y=process.env.PATTERN,Z=process.env.WATCH,Q=process.env.LESS,X=N0.resolve("jest.config.js");_.silent=!0;try{if(K)_("node",["--inspect-brk",N0.resolve("node_modules/.bin/jest"),"--runInBand",Z?"--watchAll":"","--verbose",Q==="true"?"false":void 0,"--colors","--config",X,Y?`--testNamePattern ${Y}`:""]);else K1(["jest",Z?"--watchAll":"","--verbose",Q==="true"?"false":void 0,"--colors","--config",X,Y?`--testNamePattern=${Y}`:""])}catch(G){console.warn("Tests failed. Please look at logs to see the errors discovered")}console.warn(W.cyanBright("Tests complete"))}var O2=L(()=>{D();H0();C()});var B2={};E(B2,{default:()=>{{return A2}}});async function A2(){console.warn("Running unit tests..."),await q2()}var N2=L(()=>{O2()});var w2={};E(w2,{default:()=>{{return U2}}});import I2 from"fs";import D2 from"path";import T2 from"rimraf";async function U2(){const $=D2.resolve("./node_modules/.cache/"),K=D2.resolve("./build");if(I2.existsSync($))T2.sync($),console.warn("Cache: Clean complete");else console.warn("Cache: Already clean");if(I2.existsSync(K))T2.sync(K),console.warn("Build: Clean complete");else console.warn("Build: Already clean");if(await _("bun",["pm","cache","rm"]))console.warn("Bun: Clean complete");else console.warn("Bun: Already clean")}var V2=L(()=>{C()});import C2 from"path";import{createRequire as Z4} from"module";async function m1($,K){const Q=Z4(import.meta.url).resolve($).split("node_modules"),X=Q[0],G=Q[1].split(C2.sep)[1];return C2.join(X,"node_modules",G,"node_modules",".cache",K)}var S2=L(()=>{});var b2={};E(b2,{default:()=>{{return E2}}});import Q4 from"fs-extra";import Z1 from"path";import G4 from"url";async function X4($,K,Y){const Z=await import("puppeteer"),Q=await m1("puppeteer","pr-release"),X=await Z.launch({headless:!1,userDataDir:Z1.resolve(H1,Q),defaultViewport:null}),G=await X.newPage();console.warn("Opening project url..."),await G.goto($);const z=await G.evaluate(()=>document.body.getAttribute("data-project-id"));if(!z){console.warn("No project id found, User login required...");let M=!0;X.on("disconnected",()=>{if(!M)return;console.warn("Browser was closed or crashed. Try the command again."),process.exit(1)}),await G.goto($),await G.waitForFunction(()=>{const H=document?.body?.getAttribute("data-project-id");return H!==null&&H!==void 0},{timeout:0}),await G.close(),M=!1}else await G.close();console.warn("Project ID found:",z,"\nOpening merge request...");const J=async(M,H,B)=>{const N=await X.newPage();await N.goto(`${$}/-/merge_requests/new?${B?"utf8=%E2%9C%93&":""}merge_request%5Bsource_project_id%5D=${z}&merge_request%5Bsource_branch%5D=${encodeURIComponent(M)}&merge_request%5Btarget_project_id%5D=${z}&merge_request%5Btarget_branch%5D=${H}`),await N.waitForFunction(()=>{const O=document.querySelector("#merge_request_title");return O!==null&&O!==void 0},{timeout:0}),await N.evaluate((O)=>{let F=document.querySelector("#merge_request_title");if(F)F.value=`Release ${O}`;if(F=document.querySelector("#merge_request_description"),F)F.value=`Release ${O}`;if(F=document.querySelector("#merge_request_force_remove_source_branch"),F)F.checked=!1,F.value="0"},K),await new Promise((O)=>{N.on("close",()=>{O(void 0),console.warn("Gitlab ticket process finished\n\n")})})};console.warn("\n\nWaiting for browser windows to be closed...\n\n"),await Promise.all([J("release","dev"),J("release",Y)]),X.close()}async function I0($,K,Y,Z){const Q=await import("puppeteer"),X=await m1("puppeteer","pr-release");let G=await Q.launch({headless:!Z,userDataDir:Z1.resolve(H1,X),defaultViewport:null});const z=await G.newPage();if(Z){console.warn("User login required...");let B=!0;G.on("disconnected",()=>{if(!B)return;console.warn("Browser was closed or crashed. Try the command again."),process.exit(1)});const N="https://github.com/login";console.warn("Opening github login page: ",N),await z.goto(N),await z.waitForFunction(()=>{const O=document?.body?.getAttribute("class")?.split(" ").find((F)=>F.startsWith("logged-in"));return O!==null&&O!==void 0},{timeout:0}),B=!1}else console.warn("Opening project url: ",$),await z.goto($);console.warn("Checking for logged-in attribute on body...");const J=await z.evaluate(()=>{return console.warn("logged-in check:",document?.body?.getAttribute("class")?.split(" ").find((B)=>B.startsWith("logged-in"))),document?.body?.getAttribute("class")?.split(" ").find((B)=>B.startsWith("logged-in"))});if(console.warn("Loggin in check:",J),!J&&Z)await G.close(),console.error("Failed to log in the user for github."),process.exit(1);else if(!J){console.warn("Logged-in not found on body, login might be needed..."),await G.close(),I0($,K,Y,!0);return}else G.close();const M={headless:!1,userDataDir:Z1.resolve(H1,X),defaultViewport:null};G=await Q.launch(M);const H=async(B,N)=>{const O=await G.newPage();await O.goto(`${$}/compare/${N}...${B}`),await O.waitForFunction(()=>{const F=document.querySelector("#repo-content-pjax-container > div > div.js-details-container.Details.js-compare-pr > div > button");return F?.click(),F!==null&&F!==void 0}),await O.evaluate(async(F)=>{let U=document.querySelector("#pull_request_title");if(U)U.value=`Release ${F}`;if(U=document.querySelector('[name="pull_request[body]"]'),U)U.value=`Release ${F}`},K),await new Promise((F)=>{O.on("close",()=>{F(void 0),console.warn("Github ticket process finished\n\n")})})};console.warn("\n\nWaiting for browser windows to be closed...\n\n"),await Promise.all([H("release","dev"),H("release",Y)]),G.close()}async function W4($,K,Y,Z){const Q=await import("puppeteer"),X=await m1("puppeteer","pr-release");let G=await Q.launch({headless:!Z,userDataDir:Z1.resolve(H1,X),defaultViewport:null});const z=await G.newPage();if(Z){console.warn("User login required...");let B=!0;G.on("disconnected",()=>{if(!B)return;console.warn("Browser was closed or crashed. Try the command again."),process.exit(1)});const N=$;console.warn("Opening azure repo login page: ",N),await z.goto(N),await z.waitForFunction(()=>{const O=window.sessionStorage.msameid;return O!==null&&O!==void 0},{timeout:0}),B=!1}else console.warn("Opening project url: ",$),await z.goto($);console.warn("Checking for logged-in attribute on body...");const J=await z.evaluate(()=>{return console.warn("logged-in check:",window.sessionStorage.msameid),window.sessionStorage.msameid});if(console.warn("Loggin in check:",J),!J&&Z)await G.close(),console.error("Failed to log in the user for azure."),process.exit(1);else if(!J){console.warn("MS id not found, login might be needed..."),await G.close(),I0($,K,Y,!0);return}else G.close();const M={headless:!1,userDataDir:Z1.resolve(H1,X),defaultViewport:null};G=await Q.launch(M);const H=async(B,N)=>{const O=await G.newPage();await O.goto(`${$}&sourceRef=${B}&targetRef=${N}`),await O.waitForFunction(()=>{const F=document.querySelector("button.primary");return F!==null&&F!==void 0}),await O.evaluate(async(F)=>{let U=document.querySelector('[aria-label="Enter a title"]');if(U)U.value=`Release ${F}`;if(U=document.querySelector('[aria-label="Description"]'),U)U.value=`Release ${F}`},K),await new Promise((F)=>{O.on("close",()=>{F(void 0),console.warn("Azure project ticket process finished\n\n")})})};console.warn("\n\nWaiting for browser windows to be closed...\n\n"),await Promise.all([H("release","dev"),H("release",Y)]),G.close()}async function E2($,K,Y="master",...Z){if(!(new Set(["gitlab","git","github","azure"])).has(K))console.error(`Unsupported repo type: ${K}`),process.exit(1);if(await e())console.error("You have uncommitted changes or the current state of the project can not be determined. Please commit or stash them before continuing."),process.exit(1);const G=Q4.readJsonSync(Z1.resolve("package.json")).version;switch(K){case"gitlab":await X4($,G,Y);break;case"git":case"github":await I0($,G,Y);break;case"azure":await W4($,G,Y);break;default:console.warn("No supported repo type found")}}var H1;var j2=L(()=>{S2();w1();H1=G4.fileURLToPath(new URL(".",import.meta.url))});D();import*as z4 from"commander";import J4 from"inquirer-autocomplete-prompt";import H4 from"inquirer";import R2 from"path";import F4 from"yargs";D();n();import b0 from"fs-extra";import j0 from"path";D();import w0 from"fs";import V0 from"path";function U0($){const K=$.split(/\r?\n/),Y={};let Z=null,Q=null;return K.forEach((X)=>{if(X=X.trim(),X===""||X.startsWith("#"))return;if(X.endsWith("{")){Z=X.split(/\s+/)[0],Y[Z]={};return}if(X==="}"){Z=null,Q=null;return}const G=X.match(/^([\w.]+)\s*=\s*(.*)$/);if(G){const J=G[1];let M=G[2];if(!isNaN(parseFloat(M)))M=parseFloat(M);else if(M==="true")M=!0;else if(M==="false")M=!1;if(Q)Y[Z??"null"][Q][J]=M;else if(Z)Y[Z][J]=M;else Y[J]=M;return}const z=X.match(/^([\w.]+)\.([\w.]+)\s*=\s*(.*)$/);if(z){const J=z[1],M=z[2],H=z[3];if(!Y[J])Y[J]={};if(!Y[J][M])Y[J][M]={};Y[J][M][H]=null,Z=J,Q=M;return}console.error(`Unrecognized line: ${X}`)}),Y}function C0($){try{if(!w0.existsSync(V0.resolve(".env")))return;const K=w0.readFileSync(V0.resolve($||".env"),"utf8"),Y=U0(K);Object.entries(Y).forEach(([Z,Q])=>{if(typeof Q==="string")process.env[Z]=Q;else if(typeof Q==="number")process.env[Z]=Q.toString();else if(typeof Q==="boolean")process.env[Z]=Q.toString()})}catch(K){if(K instanceof Error)console.error(W.red("Error reading .env file:\n",W.yellow(K.stack||K.message)))}}Q1();G1();import h2 from"fs-extra";import l2 from"inquirer";import{stripIndent as c2} from"common-tags";async function E0($,K,Y,Z,Q,X){let G=X||!1;if(h2.existsSync($)){const{result:z}=await l2.prompt([{type:"confirm",name:"result",message:c2`${K}`,default:X}]);if(z)Y($),Q?.($);G=z}else Y($),Z?.($);return G}async function p2(){const $=(await import(j0.resolve("env.config.ts"))).default;if(!$)throw new Error("No env.config.ts file found.");if(!Array.isArray($))console.error("env.config.ts is not formatted correctly. Please follow the correct type convention.");return $}async function d1($){C0();try{const K=await p2(),Y=[],Z=[];if(K.forEach((Q)=>{if(!Q)return;if(Q.required){if(!process.env[Q.name])Y.push(q`
              Missing: ${Q.name}\nDesription: ${Q.description}
            `)}else if(!process.env[Q.name]&&Q.warn!==!1)Z.push(q`
              Missing: ${Q.name}\nDesription: ${Q.description}
            `)}),Z.length>0)console.warn(W.yellowBrightBold("The following environment variables are recommended but missing from your environment:\n")),console.warn(W.yellowBright(q`
          ${Z.join("\n")}
        `));if(Y.length>0)console.error(W.redBrightBold("The following environment variables are required but missing from your environment:\n")),console.error(W.redBright(q`
          ${Y.join("\n")}
        `));if(Y.length>0){if($){if(await y(q`
          There seems to be some missing environment variables. Would you like
          to generate a .env file with the default values specified in the
          env.config file?
        `)){const X=[];for(let M of K)X.push([M.name,S0(M.default)?M.default:m(M.default)?await M.default():void 0]);const G=X.filter((M)=>M[1]).map((M)=>`${M[0]}=${M[1]}`).join("\n");if(!G)console.warn(q`
              There are no defaults available for this env.config. So we can not
              generate an env file you. Please review the env.config.ts file and
              properly set the default values for the required environment
              variables.
            `);const z=j0.resolve(".env");if(!await E0(z,q`
              There appears to already be a .env file.
              Would you like to add the missing defaults to it?
            `,()=>{},()=>b0.writeFile(z,G),()=>{b0.appendFileSync(z,`\n${G}`)},!1))console.error("Did not write the .env file. Please correct the env and try again."),process.exit(1);return console.warn("Attempting to build the env again and continue with the command..."),d1(!1)}}process.exit(1)}}catch(K){console.warn(q`
      No ${W.cyanBrightBold("env.config.ts")} file found. Environment will not be validated.
    `)}}n();import n2 from"fs-extra";import s2 from"inquirer";import a2 from"path";C();s();Q1();async function a($,K,Y){const Z=await P(),Q=$.filter(m);return _(Z[0],["i",Y?"--no-save":null,K?`-${K}`:null,...Q])}C();import i2 from"fuzzy";var R0=($)=>async(K,Y)=>{let Z=[];if($ instanceof Set)Z=Array.from($);else Z=$;return i2.filter(Y||"",Z).map((Q)=>Q.string)};s();async function P0($){try{return await import($),!0}catch(K){return console.error("Requested package is not available in this current project:",$),!1}}o();async function k0($,K){const Y=$||["puppeteer"];for(let Z of Y)if(console.warn("Checking on dependency availability:",Z),!await P0(Z)){let X=K;if(!X)X=(await s2.prompt([{type:"autocomplete",name:"resolution",message:`How do you want to resolve the missing package "${Z}":`,source:R0([u.InstallOnce,u.InstallAbove,u.DoNothing])}])).resolution;switch(X){case u.Install:await a([Z],"E");break;case u.InstallOnce:a([Z],"E",!0);break;case u.InstallAbove:{const G=process.cwd();process.chdir("..");const z=await P();if(!n2.existsSync(a2.resolve("package.json")))_(z[0],["init","-y"]);await a([Z],"E"),process.chdir(G),await R(100);break}default:process.exit(1)}}}var u;(function(Q){Q["Install"]="Install to current project";Q["InstallOnce"]="Install once to current project";Q["InstallAbove"]="Install in parent directory (Makes package available to all peer projects)";Q["DoNothing"]="Do Nothing (this will end this current process as the package is required)"})(u||(u={}));var D0=function(){return u1.debug=V.debug,u1.verbose=V.verbose,u1.pattern=V.pattern,u1};async function N4(){await d1(!0),V.parse(process.argv)}H4.registerPrompt("autocomplete",J4);var{Command:M4}=z4,V=new M4,u1={};V.version("0.0.1");V.option("-v, --verbose","Outputs more detailed information during crashes.");V.option("--debug [param]",q`
    Provides debugging contextual information various commands might use to
    aid in developing Devops.
  `);V.option("-p, --pattern [param]",q`
    Provides a pattern for certain operations to utilize. This is primarily
    used by unit tests to filter tests to specified tests.
  `);var P2=V.command("dev").description(q`
    These are the commands associated with starting up developer environments
    for various project types or portions of a project.
  `);P2.command("vite").description(q`
      Starts up a developer environment that performs incremental builds while
      developing within the lib and app folders. Uses vite and vite
      config.
    `).action(async()=>{(await Promise.resolve().then(() => (d0(),g0))).default().catch(($)=>{console.warn("dev-vite process exited unexpectedly"),console.warn($.stack||$.message),process.exit(1)})});P2.command("storybook").option("-i, --include <include...>","Additional storybook modules to load into storybook. These are the names of properly formatted dependencies installed into node_modules.").description(q`
      Starts a storybook instance for developing the UI components of the
      project. This makes the "ui/stories" folder in the project the expected
      development point.
    `).action(async({include:$})=>{(await Promise.resolve().then(() => (e1(),r1))).default("",$,R2.resolve(process.cwd()),D0()).catch((K)=>{console.warn("storybook process exited unexpectedly"),console.warn(K.stack||K.message),process.exit(1)})});var L4=V.command("storybook");L4.command("run").option("-i, --include <include...>","Additional storybook modules to load into storybook. These are the names of properly formatted dependencies installed into node_modules.").description(q`
      Starts a storybook instance for developing the UI components of the
      project. This makes the "ui/stories" folder in the project the expected
      development point.
    `).action(async({include:$})=>{(await Promise.resolve().then(() => (e1(),r1))).default("",$,R2.resolve(process.cwd()),D0()).catch((K)=>{console.warn("storybook process exited unexpectedly"),console.warn(K.stack||K.message),process.exit(1)})});V.command("url [uri...]").description(q`
      Simple command to open a specified URL in the browser.
    `).action(async($)=>{(await Promise.resolve().then(() => (q$(),_$))).default($).catch((K)=>{console.warn("url process exited unexpectedly"),console.warn(K.stack||K.message),process.exit(1)})});var F1=V.command("release").description(q`
    These commands are used for facilitating distribution releases of
    applications. This includes tools for building th dist folder fragments,
    viewing the expected release notes, and actually performing a complete
    release cycle.
  `);F1.command("deploy [add-remote...]").description(q`
      Performs actions necessary to update the distribution of the project.
      This will automatically update release notes, tag the release, and
      commit and push to a 'release' branch which will be ready for merging
      into master and dev.

      Specify additional remotes to deploy to via the add-remote option.
      This will deploy the release to additional remotes (AFTER all other normal
      deploy operations complete). This value is the NAME of the remote as it
      appears when you perform a "git remote -v" command.

      You can specify a specific target branch via a colon: remote:branch
      Otherwise, this will use the same main branch as configured for this
      project.
    `).action(async($)=>{a([]),(await Promise.resolve().then(() => ($2(),e$))).default($).catch((K)=>{console.warn("release-deploy process exited unexpectedly\n",K.stack||K.message),process.exit(1)})});F1.command("types").description(q`
      Updates JUST the types in the dist folder. These are the same types
      generated when building a release.
    `).action(async()=>{(await Promise.resolve().then(() => (Z2(),Y2))).default().catch(($)=>{console.warn("release-types process exited unexpectedly\n",$.stack||$.message),process.exit(1)})});F1.command("view").description(q`
      This runs the release-view script. For this case, it will only display
      the release notes in the console. Actual generated release notes are a
      part of the release process.
    `).action(async()=>{(await Promise.resolve().then(() => (A0(),O0))).default("").then(async()=>{console.warn(W.cyanBrightBold("TS check passed, generating notes...")),(await Promise.resolve().then(() => (_0(),h$))).default().catch(($)=>{console.warn("release-notes process exited unexpectedly",$.stack||$.message),process.exit(1)})}).catch(($)=>{console.warn(W.redBrightBold(q`
              Failed TS check. Release notes will not be produced until all TS
              errors are resolved.
            `)),console.warn($.stack||$.message),process.exit(1)})});F1.command("build").description(q`
      This runs the release-build script. This generates all of the release
      fragments. This should ONLY be used for testing and experimenting. Actual
      release fragments should be properly created and deployed using the
      release deploy command.
    `).action(async()=>{(await Promise.resolve().then(() => (L0(),f$))).default().catch(($)=>{console.warn("release-deploy process exited unexpectedly\n",$.stack||$.message),process.exit(1)})});var _4=F1.command("start").description(q`
      This starts up released related processes. This includes things like
      starting up the dev server without any additional builds or auto
      configuration for development.
    `);_4.command("server").description(q`
      Starts up the app server without any additional builds etc. Use the
      environments:

        BUILD_MODE: Targets an env to run the server for.
        RESOURCE_PATH: The path to the static files to serve.
    `).action(async()=>{(await Promise.resolve().then(() => (z2(),W2))).default().catch(($)=>{console.warn("release-start-server process exited unexpectedly\n",$.stack||$.message),process.exit(1)})});V.command("start [target]").description(q`
      This fires up a server to make any static content available for being
      served.
      There are a few options for what content will be served by this script:

      - The web app
      - Devops API

      The start script will automatically pick the web app over the devops
      files, but you can specify a target if you have a devops API and a web
      app:

      - app
      - devops
    `).action(async($)=>{(await Promise.resolve().then(() => (_2(),L2))).default($,D0()).catch((K)=>{console.warn("start process exited unexpectedly"),console.warn(K.stack||K.message),process.exit(1)})});var q4=V.command("test").description(q`
    These commands are used for running tests. This includes tools for
    running unit tests a single time or in a watch mode.

    Use the environment variables for modifying behavior:

    ${W.yellowBrightBold("PATTERN")} - This causes the tests to only run on
    files that match the pattern

    ${W.yellowBrightBold("LESS")} - This removes the verbose output list of
    all tests ran
  `);q4.command("run").description(q`
      Runs all unit tests in the unit-test folder once.
    `).action(async()=>{(await Promise.resolve().then(() => (N2(),B2))).default().catch(($)=>{console.warn("test-run process exited unexpectedly"),console.warn($.stack||$.message),process.exit(1)})});var O4=V.command("clean").description(q`
    Common cleaning tools for various fragments within the project.
  `);O4.command("cache").description(q`
      Cleans out build and cache files to help ensure a complete rebuild takes
      place.
    `).action(async()=>{(await Promise.resolve().then(() => (V2(),w2))).default().catch(($)=>{console.warn("clean-cache process exited unexpectedly"),console.warn($.stack||$.message),process.exit(1)})});var A4=V.command("ts").description(q`
    These commands are used for running typescript. This includes tools for
    running typescript compilation a single time or in a watch mode.
  `);A4.command("run").description(q`
      Runs typescript compilation to check for errors. Does NOT emit files, thus
      is a good mechanism for checking a build before running a release.
    `).action(async()=>{(await Promise.resolve().then(() => (A0(),O0))).default("").catch(($)=>{console.warn("ts process exited unexpectedly"),console.warn($.stack||$.message),process.exit(1)})});var B4=V.command("pr").option("--repoUrl <value>",q`
      The https URL to the repo to make the PR into
    `).option("--repoType <value>",q`
    The repository type to make the PR into. Supported types are: git, gitlab
  `).option("--masterBranch <value>",q`
    This indicates which branch is the master/main of the repository.
  `);B4.command("release").description(q`
      This creates two PRs that merges the current remote release branch into
      the remote dev and master branches.
    `).action(async()=>{const{repoUrl:$,repoType:K,masterBranch:Y}=F4(process.argv).argv;if(!$||!K||!Y)console.warn("You must specify both --repoUrl and --repoType to use this command"),process.exit(1);await k0().catch(()=>process.exit(1)),console.warn("Dependency checks passed, continuing..."),(await Promise.resolve().then(() => (j2(),b2))).default($,K,Y).catch((Z)=>{console.warn("pr-release process exited unexpectedly"),console.warn(Z.stack||Z.message),process.exit(1)})});N4();
