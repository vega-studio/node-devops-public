#!/usr/bin/env bun
// @bun
var P2=Object.create;var{defineProperty:u1,getPrototypeOf:k2,getOwnPropertyNames:y2}=Object;var x2=Object.prototype.hasOwnProperty;var v2=($,K,Y)=>{Y=$!=null?P2(k2($)):{};const Z=K||!$||!$.__esModule?u1(Y,"default",{value:$,enumerable:!0}):Y;for(let Q of y2($))if(!x2.call(Z,Q))u1(Z,Q,{get:()=>$[Q],enumerable:!0});return Z};var F1=($,K)=>()=>(K||$((K={exports:{}}).exports,K),K.exports);var E=($,K)=>{for(var Y in K)u1($,Y,{get:K[Y],enumerable:!0,configurable:!0,set:(Z)=>K[Y]=()=>Z})};var L=($,K)=>()=>($&&(K=$($=0)),K);var W;var I=L(()=>{W={cyan:(...$)=>`\x1B[36m${$.join(" ")}\x1B[0m`,red:(...$)=>`\x1B[31m${$.join(" ")}\x1B[0m`,yellow:(...$)=>`\x1B[33m${$.join(" ")}\x1B[0m`,green:(...$)=>`\x1B[32m${$.join(" ")}\x1B[0m`,blue:(...$)=>`\x1B[34m${$.join(" ")}\x1B[0m`,magenta:(...$)=>`\x1B[35m${$.join(" ")}\x1B[0m`,cyanBright:(...$)=>`\x1B[96m${$.join(" ")}\x1B[0m`,redBright:(...$)=>`\x1B[91m${$.join(" ")}\x1B[0m`,yellowBright:(...$)=>`\x1B[93m${$.join(" ")}\x1B[0m`,greenBright:(...$)=>`\x1B[92m${$.join(" ")}\x1B[0m`,blueBright:(...$)=>`\x1B[94m${$.join(" ")}\x1B[0m`,magentaBright:(...$)=>`\x1B[95m${$.join(" ")}\x1B[0m`,whiteBright:(...$)=>`\x1B[97m${$.join(" ")}\x1B[0m`,gray:(...$)=>`\x1B[90m${$.join(" ")}\x1B[0m`,grey:(...$)=>`\x1B[90m${$.join(" ")}\x1B[0m`,white:(...$)=>`\x1B[37m${$.join(" ")}\x1B[0m`,black:(...$)=>`\x1B[30m${$.join(" ")}\x1B[0m`,blackBright:(...$)=>`\x1B[90m${$.join(" ")}\x1B[0m`,bgCyan:(...$)=>`\x1B[46m${$.join(" ")}\x1B[0m`,bgRed:(...$)=>`\x1B[41m${$.join(" ")}\x1B[0m`,bgYellow:(...$)=>`\x1B[43m${$.join(" ")}\x1B[0m`,bgGreen:(...$)=>`\x1B[42m${$.join(" ")}\x1B[0m`,bgBlue:(...$)=>`\x1B[44m${$.join(" ")}\x1B[0m`,bgMagenta:(...$)=>`\x1B[45m${$.join(" ")}\x1B[0m`,bgCyanBright:(...$)=>`\x1B[106m${$.join(" ")}\x1B[0m`,bgRedBright:(...$)=>`\x1B[101m${$.join(" ")}\x1B[0m`,bgYellowBright:(...$)=>`\x1B[103m${$.join(" ")}\x1B[0m`,bgGreenBright:(...$)=>`\x1B[102m${$.join(" ")}\x1B[0m`,bgBlueBright:(...$)=>`\x1B[104m${$.join(" ")}\x1B[0m`,bgMagentaBright:(...$)=>`\x1B[105m${$.join(" ")}\x1B[0m`,cyanBrightBold:(...$)=>`\x1B[96m\x1B[1m${$.join(" ")}\x1B[0m`,redBrightBold:(...$)=>`\x1B[91m\x1B[1m${$.join(" ")}\x1B[0m`,yellowBrightBold:(...$)=>`\x1B[93m\x1B[1m${$.join(" ")}\x1B[0m`,greenBrightBold:(...$)=>`\x1B[92m\x1B[1m${$.join(" ")}\x1B[0m`,blueBrightBold:(...$)=>`\x1B[94m\x1B[1m${$.join(" ")}\x1B[0m`,magentaBrightBold:(...$)=>`\x1B[95m\x1B[1m${$.join(" ")}\x1B[0m`,whiteBrightBold:(...$)=>`\x1B[97m\x1B[1m${$.join(" ")}\x1B[0m`,grayBrightBold:(...$)=>`\x1B[90m\x1B[1m${$.join(" ")}\x1B[0m`,greyBrightBold:(...$)=>`\x1B[90m\x1B[1m${$.join(" ")}\x1B[0m`,whiteBold:(...$)=>`\x1B[37m\x1B[1m${$.join(" ")}\x1B[0m`,blackBold:(...$)=>`\x1B[30m\x1B[1m${$.join(" ")}\x1B[0m`,blackBrightBold:(...$)=>`\x1B[90m\x1B[1m${$.join(" ")}\x1B[0m`}});import{stripIndent as f2} from"common-tags";function q($,...K){return`${f2($,...K)}\n\n`}var i=L(()=>{});function C0($){return $&&$.charCodeAt!==void 0}function f($){return $!==void 0&&$!==null}var Z1=L(()=>{});import m2 from"inquirer";import{stripIndent as u2} from"common-tags";async function k($,K,Y){const{result:Z}=await m2.prompt([{type:"confirm",name:"result",message:u2`${$}`,default:K}]);if(Z)Y?.();return Z}var Q1=L(()=>{});function M1($){return h1($)&&h1($.status)&&h1($.stderr)}var h1;var d1=L(()=>{h1=function($){return $!==void 0&&$!==null}});async function L1($,K=[]){try{const Y=Bun.spawnSync([$,...K.filter(f)],{stdio:["inherit","inherit","inherit"],env:process.env});if(Y.exitCode!==0){if(!L1.silent)console.error(`Error: ${$} ${K.join(" ")} failed with code: ${Y.exitCode}`),console.error(new Error().stack);return!1}}catch(Y){if(!L1.silent){if(M1(Y))console.error(`Error: ${$} ${K.join(" ")} failed with code: ${Y.status}`);else if(Y instanceof Error)console.error(Y.message);console.error(new Error().stack)}return!1}return!0}var _;var C=L(()=>{d1();Z1();L1.silent=!1;_=L1});async function P(){if(G1)return G1;if(await _("bun",["--version"]))G1=["bun","bunx"];else G1=["npm","npx"];return G1}var G1;var n=L(()=>{C();G1=null});async function R($){await new Promise((K)=>setTimeout(K,$))}var a=L(()=>{});import s2 from"fs-extra";import g from"path";async function o(){console.warn("Building Vite config using base:",W.yellowBrightBold(g.resolve("vite.config.ts")));let $=await(await import(g.resolve("vite.config.ts"))).default();const K=await s2.readJSONSync(g.resolve("tsconfig.json"));return $={...$,logLevel:"info",mode:"development",root:g.resolve("app/client"),clearScreen:!0,build:{...$.build,cssCodeSplit:!0,outDir:g.resolve("build/client"),sourcemap:!0,rollupOptions:{output:{manualChunks:void 0}},watch:{...$.build?.watch,include:[...(Array.isArray($.build?.watch?.include)?$.build?.watch?.include:[$.build?.watch?.include])||[],...K?.include?.map((Y)=>g.resolve(Y))||[],"tsconfig.json"].filter(Boolean)},emptyOutDir:!0},resolve:{alias:{config:g.resolve("app/config")}}},$}var _1=L(()=>{I()});import a2 from"deepmerge";import o2 from"fs-extra";import t2 from"path";async function h(){const $=o2.readJSONSync(t2.resolve("package.json"));return a2($.dependencies||{},$.peerDependencies||{})}var q1=L(()=>{});import r2 from"fs-extra";import e2 from"path";async function w(){return r2.readJSONSync(e2.resolve("package.json")).version||""}var y=L(()=>{});import*as k0 from"vite";import $3 from"fs-extra";import l1 from"path";async function X1(){if(process.env.VITE_RELEASE_VERSION=process.env.VITE_RELEASE_VERSION||await w(),console.warn(W.yellowBrightBold("Starting Vite client build...")),!$3.existsSync(l1.resolve("app/client/index.ts"))){console.warn("Tried to start development process for the app client, but no entry file was found.");return}const $=await o();$.root=l1.resolve("app/client"),$.build.outDir=l1.resolve("build/client"),$.build.rollupOptions.external=Object.keys(await h()),await k0.build($),console.warn(W.yellowBrightBold("Vite client build process started..."))}var p1=L(()=>{_1();I();q1();y()});function y0($){const K=(Y)=>(Z)=>{if($(Y,Z),Z)process.exit(1);else process.exit(0)};process.on("exit",K("exit")),process.on("SIGINT",K("SIGINT")),process.on("SIGUSR1",K("SIGUSR1")),process.on("SIGUSR2",K("SIGUSR2")),process.on("SIGTERM",K("SIGTERM")),process.on("uncaughtException",K("uncaughtException"))}var x0=L(()=>{});function i1(...$){c1.push($),K3()}var K3,c1,v0;var f0=L(()=>{K3=function(){if(v0!==null)return;v0=setInterval(()=>{while(c1.length>0){const $=c1.shift();if($)console.log(...$)}},400)};c1=[],v0=null});import Y3 from"child_process";import n1 from"path";import Z3 from"readline";async function W1($){console.warn("\nRunning the App server at: ",W.yellowBrightBold(n1.resolve("app/server")),"\n"),process.env.VITE_RELEASE_VERSION=process.env.VITE_RELEASE_VERSION||await w(),process.env.RESOURCE_PATH=process.env.RESOURCE_PATH||n1.resolve("build/client");const K=await P();if(K[0]!=="bun")console.error("Currently only an environment with bun installed is supported for this command.");const Y=Y3.spawn(K[0],["--watch",n1.resolve("app/server/index.ts")]);process.stdin.setRawMode?.(!0),process.stdin.resume(),process.stdin.setEncoding("utf8"),Z3.emitKeypressEvents(process.stdin);let Z=!1;if(process.stdin.on("keypress",async(Q,G)=>{if(G&&G.ctrl&&G.name==="c")Y.kill(),process.exit(0);else if(G&&G.ctrl&&G.name==="d")Y.kill(),process.exit(0);else if(Q.toString()==="b"||Q.toString()==="B"){if(Z)return;Z=!0,await X1(),Z=!1}else if(Q.toString()==="q"||Q.toString()==="Q")if(Y.kill(),G.shift)process.exit(123);else process.exit(0)}),process.stdin.pipe(Y.stdin),$)$(Y);else Y.stdout.on("data",function(Q){i1(`${Q.toString().slice(0,-1)}`)}),Y.stderr.on("data",function(Q){i1(`${Q.toString().slice(0,-1)}`)});y0(async(Q,G)=>{if(Y.kill(),console.warn("EXIT BUILD SERVER"),console.warn(W.redBrightBold(Q)),G&&G instanceof Error)console.warn(W.redBrightBold(G.stack||G.message));process.exit(0)})}var s1=L(()=>{p1();I();n();x0();f0();y()});var u0={};E(u0,{default:()=>{{return m0}}});async function m0(){process.env.NODE_ENV="development",X1(),console.warn(W.yellowBrightBold("Starting dev server...")),process.env.VITE_RELEASE_VERSION=await w(),await W1()}var g0=L(()=>{p1();s1();I();y()});import O1 from"path";import Q3 from"url";async function h0(){if(O1.basename(O1.resolve(a1,".."))==="dist")return O1.resolve(a1,"../../");return O1.resolve(a1,"../../../")}var a1;var d0=L(()=>{a1=Q3.fileURLToPath(new URL(".",import.meta.url))});async function d($,K=[]){const Y=await P();return _(Y[0],["run",$,K.length>0&&K[0]!=="--"?"--":void 0,...K])}var D1=L(()=>{C();n()});var t1={};E(t1,{default:()=>{{return l0}}});import o1 from"path";async function l0($,K,...Y){const Z=o1.resolve(".");process.env.PROJECT_ROOT=Z,process.env.VITE_RELEASE_VERSION=await w();const Q=o1.resolve(".storybook"),G=await h0();if(process.chdir(G),K&&K.length>0)process.env.NODE_MODULES_STORIES=K.join(",");if($==="build"){if(!d("storybook",["build","-c",Q,"-o",o1.resolve(Z,"storybook-static")]))console.error(W.redBrightBold("Failed to build storybook"))}else if(!d("storybook",["dev","--no-version-updates","-p",process.env.PORT||"6006","-c",Q]))console.error(W.redBrightBold("Failed to run storybook"))}var r1=L(()=>{I();d0();D1();y()});var $0=F1((GK,c0)=>{var G3=function(){try{return p0.statSync("/.dockerenv"),!0}catch($){return!1}},X3=function(){try{return p0.readFileSync("/proc/self/cgroup","utf8").includes("docker")}catch($){return!1}},p0=import.meta.require("fs"),e1;c0.exports=()=>{if(e1===void 0)e1=G3()||X3();return e1}});var s0=F1((XK,K0)=>{var W3=import.meta.require("os"),z3=import.meta.require("fs"),i0=$0(),n0=()=>{if(process.platform!=="linux")return!1;if(W3.release().toLowerCase().includes("microsoft")){if(i0())return!1;return!0}try{return z3.readFileSync("/proc/version","utf8").toLowerCase().includes("microsoft")?!i0():!1}catch($){return!1}};if(process.env.__IS_WSL_TEST__)K0.exports=n0;else K0.exports=n0()});var o0=F1((WK,a0)=>{a0.exports=($,K,Y)=>{const Z=(Q)=>Object.defineProperty($,K,{value:Q,enumerable:!0,writable:!0});return Object.defineProperty($,K,{configurable:!0,enumerable:!0,get(){const Q=Y();return Z(Q),Q},set(Q){Z(Q)}}),$}});var Z$=F1((zK,Y$)=>{var L3=function(){if(Y0===void 0)Y0=M3()||F3();return Y0},$$=function($){if(typeof $==="string"||Array.isArray($))return $;const{[r0]:K}=$;if(!K)throw new Error(`${r0} is not supported`);return K},G0=function({[t]:$},{wsl:K}){if(K&&A1)return $$(K);if(!$)throw new Error(`${t} is not supported`);return $$($)},__dirname="/Users/diniden/Desktop/VoidRay/dev-ops/node-devops/node_modules/open",J3=import.meta.require("path"),H3=import.meta.require("child_process"),{promises:N1,constants:K$}=import.meta.require("fs"),A1=s0(),F3=$0(),Z0=o0(),t0=J3.join(__dirname,"xdg-open"),{platform:t,arch:r0}=process,M3=()=>{try{return N1.statSync("/run/.containerenv"),!0}catch{return!1}},Y0,_3=(()=>{let K;return async function(){if(K)return K;const Y="/etc/wsl.conf";let Z=!1;try{await N1.access(Y,K$.F_OK),Z=!0}catch{}if(!Z)return"/mnt/";const Q=await N1.readFile(Y,{encoding:"utf8"}),G=/(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(Q);if(!G)return"/mnt/";return K=G.groups.mountPoint.trim(),K=K.endsWith("/")?K:`${K}/`,K}})(),e0=async($,K)=>{let Y;for(let Z of $)try{return await K(Z)}catch(Q){Y=Q}throw Y},B1=async($)=>{if($={wait:!1,background:!1,newInstance:!1,allowNonzeroExitCode:!1,...$},Array.isArray($.app))return e0($.app,(z)=>B1({...$,app:z}));let{name:K,arguments:Y=[]}=$.app||{};if(Y=[...Y],Array.isArray(K))return e0(K,(z)=>B1({...$,app:{name:z,arguments:Y}}));let Z;const Q=[],G={};if(t==="darwin"){if(Z="open",$.wait)Q.push("--wait-apps");if($.background)Q.push("--background");if($.newInstance)Q.push("--new");if(K)Q.push("-a",K)}else if(t==="win32"||A1&&!L3()&&!K){const z=await _3();if(Z=A1?`${z}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`:`${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`,Q.push("-NoProfile","-NonInteractive","\u2013ExecutionPolicy","Bypass","-EncodedCommand"),!A1)G.windowsVerbatimArguments=!0;const J=["Start"];if($.wait)J.push("-Wait");if(K){if(J.push(`"\`"${K}\`""`,"-ArgumentList"),$.target)Y.unshift($.target)}else if($.target)J.push(`"${$.target}"`);if(Y.length>0)Y=Y.map((M)=>`"\`"${M}\`""`),J.push(Y.join(","));$.target=Buffer.from(J.join(" "),"utf16le").toString("base64")}else{if(K)Z=K;else{const z=!__dirname||__dirname==="/";let J=!1;try{await N1.access(t0,K$.X_OK),J=!0}catch{}Z=process.versions.electron||t==="android"||z||!J?"xdg-open":t0}if(Y.length>0)Q.push(...Y);if(!$.wait)G.stdio="ignore",G.detached=!0}if($.target)Q.push($.target);if(t==="darwin"&&Y.length>0)Q.push("--args",...Y);const X=H3.spawn(Z,Q,G);if($.wait)return new Promise((z,J)=>{X.once("error",J),X.once("close",(M)=>{if(!$.allowNonzeroExitCode&&M>0){J(new Error(`Exited with code ${M}`));return}z(X)})});return X.unref(),X},Q0=($,K)=>{if(typeof $!=="string")throw new TypeError("Expected a `target`");return B1({...K,target:$})},q3=($,K)=>{if(typeof $!=="string")throw new TypeError("Expected a `name`");const{arguments:Y=[]}=K||{};if(Y!==void 0&&Y!==null&&!Array.isArray(Y))throw new TypeError("Expected `appArguments` as Array type");return B1({...K,app:{name:$,arguments:Y}})},I1={};Z0(I1,"chrome",()=>G0({darwin:"google chrome",win32:"chrome",linux:["google-chrome","google-chrome-stable","chromium"]},{wsl:{ia32:"/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",x64:["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe","/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]}}));Z0(I1,"firefox",()=>G0({darwin:"firefox",win32:"C:\\Program Files\\Mozilla Firefox\\firefox.exe",linux:"firefox"},{wsl:"/mnt/c/Program Files/Mozilla Firefox/firefox.exe"}));Z0(I1,"edge",()=>G0({darwin:"microsoft edge",win32:"msedge",linux:["microsoft-edge","microsoft-edge-dev"]},{wsl:"/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"}));Q0.apps=I1;Q0.openApp=q3;Y$.exports=Q0});async function B($,K=[]){try{const Y=Bun.spawnSync([$,...K.filter(f)],{stdio:["inherit","pipe","pipe"],env:process.env});if(Y.exitCode!==0)return console.error(`Error: ${$} ${K.join(" ")} failed with code: ${Y.exitCode}`),console.error(new Error().stack),null;return(Y.stdout||"").toString()}catch(Y){if(M1(Y))console.error(`Error: ${$} ${K.join(" ")} failed with code: ${Y.status}`);else if(Y instanceof Error)console.error(Y.message);return console.error(new Error().stack),null}}var l=L(()=>{d1();Z1()});function Q$({template:$,options:K,required:Y,doubleCurlyBrackets:Z,onError:Q,onToken:G}){const X=new Map,z=new Map,J=new Map,M=new Map;let H=/\$\{([^\}]*)\}/g;if(Z)H=/\$\{\{([^\}]*)\}\}/g;const D=$.replace(H,(O,F)=>{let T="";if(M.set(F,(M.get(F)||0)+1),F in K){X.set(F,(X.get(F)||0)+1);const I0=K[F];if(I0!==void 0)T=I0}else z.set(F,(z.get(F)||0)+1);if(G){if(T=G(F,T),T!==F)X.set(F,(X.get(F)||0)+1),z.delete(F)}return T});Object.keys(K).forEach((O)=>{if(!X.get(O))J.set(O,(J.get(O)||0)+1)});const A={resolvedtemplateOptions:X,template:D,templateProvidedOptions:M,unresolvedProvidedOptions:J,unresolvedTemplateOptions:z};if(Y)Y.values.forEach((O)=>{if(A.unresolvedProvidedOptions.get(O)){const F=`${Y.name}: Could not resolve all the required inputs. Input: ${O}`;if(Q)Q(F);else console.error(F)}else if(A.unresolvedTemplateOptions.get(O)){const F=`${Y.name}: A required option was not provided in the options parameter. Option: ${O}`;if(Q)Q(F);else console.error(F)}else if(!A.resolvedtemplateOptions.get(O)){const F=`${Y.name}: A required option was not provided in the options parameter. Option: ${O}`;if(Q)Q(F);else console.error(F)}});return A}var G$=L(()=>{});var L$={};E(L$,{default:()=>{{return M$}}});import T1 from"fs-extra";import X$ from"hostile";import F$ from"path";import W$ from"valid-url";async function D3(){const K=T1.readJSONSync(F$.resolve("package.json")).hosts;if(!K)return;const Y=Object.keys(K);let Z=await z$(X$,"get",!1);const Q=[];console.warn(W.yellow("Updating hosts file..."));for(let X of Y)try{if(!Z.find((z)=>z[0]===X&&z[1]===K[X]))Q.push([X,K[X]])}catch(z){if(z instanceof Error)console.warn(W.red(z.message))}if(Q.length>0){console.warn(W.yellow("Adding hosts (You may be prompted for administrator password):\n\t",Q.map((z)=>`${z[0]} => ${z[1]}`).join("\n\t"))),await _("sudo",["echo","Granted sudo access to update hosts file."]);const X=await B("stat",["-f","%p","/etc/hosts"]).toString();await _("sudo",["chmod","666","/etc/hosts"]);for(let z of Q)T1.appendFileSync("/etc/hosts",`${z[0]} ${z[1]}`);T1.appendFileSync("/etc/hosts","\n"),await _("sudo",["chmod",X.substring(X.length-4).trim(),"/etc/hosts"])}await R(500),console.warn(W.yellow("Verifying hosts file...")),Z=await z$(X$,"get",!1);let G=!1;if(Q.forEach(([X,z])=>{if(!Z.find((J)=>J[0]===X&&J[1]===K[X]))G=!0,console.warn(W.redBright(`Failed to add host: ${W.yellowBright(X)} => ${W.yellowBright(z)}`))}),G)console.warn(W.red(q`
        *************************************************************************
        * Some hosts specified in the package.json were not able to be written  *
        * to the hosts file for the system. You can amend this by editing the   *
        * file yourself, or by trying to run this script again as an admin.     *
        *************************************************************************
      `))}async function M$($,K){const Z=T1.readJSONSync(F$.resolve("package.json"))?.url||{},Q=K?.reduce((X,z,J)=>{return X[`${J+1}`]=z,X},{})||{};if(!$||$.length<=0){console.warn(q`
      Available URLs:
        ${W.cyanBrightBold(Object.keys(Z).join("\n        "))}
    `);return}await D3();const G={...process.env,...Q};if(Array.isArray($))$.forEach((X)=>{J$(Z,X,G)});else J$(Z,$,G)}var H$,O3,z$,J$;var _$=L(()=>{H$=v2(Z$(),1);I();i();C();l();G$();a();O3=function($){return $&&typeof $==="function"},z$=function($,K,...Y){return new Promise((Z,Q)=>{const G=$[K];if(!O3(G)){Q(new Error(`${String(K)} is not a function`));return}G(...Y,(X,z)=>{if(X)console.warn(X),Q(X),process.exit(1);else Z(z||void 0)})})};J$=function($,K,Y){let Z=K;if(W$.isWebUri(K))Z=K;else if($[K])Z=$[K];const Q=Q$({options:Y,template:Z});if(Q.unresolvedTemplateOptions.size>0)throw console.warn(W.red(q`
          You must specify these env variables for this URL to work:
          ${Array.from(Q.unresolvedTemplateOptions.keys()).join("\n\t")}
        `)),new Error("Missing env configuration for URL");if(Z=Q.template,W$.isWebUri(Z))console.warn("Navigating to:",W.cyanBrightBold(Z)),H$.default(Z);else console.warn("Can not open invalid URL:",W.redBrightBold(Z))}});import A3 from"child_process";async function r(){try{A3.execSync("git status --porcelain=v1 2>/dev/null | wc -l | grep 0",{env:process.env})}catch($){return!0}return!1}var w1=L(()=>{});async function U1($){if($){if(!await k(`
      Would you like to return back to development?
      Runs the following:
        git fetch
        git checkout dev
        git reset --hard origin/dev
    `))return}if(await r())return console.error("Can not return to dev branch as changes are present on the current branch."),!1;let K=!1;if(!await _("git",["fetch"]))K=!0;if(!await _("git",["checkout","dev"]))K=!0;if(!await _("git",["reset","--hard","origin/dev"]))K=!0;if(K)return console.error("Could not return to dev branch."),!1;return!0}var X0=L(()=>{C();w1();Q1()});import U from"fs-extra";import N3 from"ignore";import N from"path";async function B3(){const $=await h();console.warn("Building full distribution...");let K=await Bun.build({entrypoints:[N.resolve("./bin/main.ts")],target:"bun",external:Object.keys($),minify:!0});for(let Y of K.outputs)console.warn("Writing bin bundle resource:",W.cyanBrightBold(Y.path)),await Bun.write(N.resolve("./dist/bin",Y.path),Y);console.warn("Building gimped distribution..."),K=await Bun.build({entrypoints:[N.resolve("./bin/main-gimp.ts")],target:"bun",external:Object.keys($),minify:!0});for(let Y of K.outputs)console.warn("Writing bin bundle resource:",W.cyanBrightBold(Y.path)),await Bun.write(N.resolve("./dist/bin",Y.path),Y)}async function I3(){if(!U.existsSync(N.resolve("./bin/shim")))console.error("No shim distribution files found to be built");if(U.existsSync(N.resolve("./shim")))U.removeSync(N.resolve("./shim"));const $=await h();console.warn("Building shim distribution...");const K=await Bun.build({entrypoints:[N.resolve("./bin/shim/index.ts")],target:"node",external:Object.keys($),minify:!0});for(let Z of K.outputs)console.warn("Writing shim bundle resource:",W.cyanBrightBold(Z.path)),await Bun.write(N.resolve("./shim/src/bin/shim",Z.path),Z);U.writeFileSync(N.resolve("./shim/index.js"),'export * from "./src/bin/shim/index.js";\n',{encoding:"utf-8"}),U.writeFileSync(N.resolve("./shim/index.d.ts"),'export * from "./src/bin/shim/index.d.ts";\n',{encoding:"utf-8"});const Y=U.readJSONSync(N.resolve("tsconfig.json"));if(Y.exclude=Y.exclude||[],Y.exclude.push("./bin/lib/**"),Y.include=["./bin/shim"],U.writeJSONSync(N.resolve("tsconfig.temp.json"),Y),await R(500),!_("tsc",["-d","--emitDeclarationOnly","--pretty","--outDir",N.resolve("./shim/src/bin"),"--project",N.resolve("tsconfig.temp.json")]))console.warn("Failed to compile type declarations for the shim files."),U.removeSync(N.resolve("tsconfig.temp.json")),process.exit(1);U.removeSync(N.resolve("tsconfig.temp.json"))}async function T3(){console.warn(W.yellowBright("Copying template files for bin distribution")),U.copySync(N.resolve(__dirname,"../../template"),N.resolve("./dist/bin/template")),console.warn(W.yellowBright("Copying entry shell script for bin distribution")),U.copySync(N.resolve("./bin/main-entry.sh"),N.resolve("./dist/bin/main-entry.sh"))}async function O$(){if(console.warn(W.cyanBright("Building bin commands for the distribution.")),!U.existsSync(N.resolve("./bin/main.ts"))||!U.existsSync(N.resolve("./bin/main-entry.sh"))||W0.ignores("bin")){console.warn(`Tried to make a release for the bin commands, but no bin/main.ts or bin/main.sh entry file was found. (or was gitignored):\n\t${N.resolve("./bin/main.ts")}\n\t${N.resolve("./bin/main.sh")}`);return}U.ensureDirSync(N.resolve("./dist")),U.ensureDirSync(N.resolve("./dist/bin/template")),await B3(),await I3(),await T3()}var __dirname,q$,W0;var D$=L(()=>{I();C();q1();a();__dirname="/Users/diniden/Desktop/VoidRay/dev-ops/node-devops/bin/lib/build/bin",q$=N.resolve(".gitignore"),W0=N3.default();if(U.existsSync(q$))W0=W0.add(U.readFileSync(q$).toString())});import A$ from"fs";import N$ from"path";function B$($){return{name:"vite-devops-string-replace-plugin",enforce:"pre",load(K){const Y=N$.resolve(K),Z=[".ts",".js",".tsx",".jsx"];if(A$.existsSync(Y)&&Z.includes(N$.extname(Y))&&!Y.includes("node_modules")&&!Y.includes("\0")){let Q=A$.readFileSync(Y,{encoding:"utf-8"});return $.forEach((G)=>{Q=Q.replace(G.from,G.to)}),Q}}}}var I$=L(()=>{});import b from"fs-extra";import j from"path";function T$($){const K=process.env.PROJECT_ROOT||".",Y=j.resolve(K,"app/config");if(!b.existsSync(Y)){console.warn(`viteDevopsAppConfigPlugin: ${W.cyanBrightBold("No app/config folder found.")}`);return}try{const Z=b.readdirSync(Y).filter((H)=>{return b.statSync(j.join(Y,H)).isDirectory()}),Q=Z.map((H)=>j.join(Y,H)),X=Z.map((H,D)=>{if(!$)if(b.existsSync(j.join(Q[D],`${H}.local`))||b.existsSync(j.join(Q[D],`${H}.local.js`))||b.existsSync(j.join(Q[D],`${H}.local.ts`))||b.existsSync(j.join(Q[D],`${H}.local.tsx`))||b.existsSync(j.join(Q[D],`${H}.local.jsx`)))return[{from:`"config/${H}/${H}"`,to:`"config/${H}/${H}.local"`},{from:`"config/${H}/${H}.js"`,to:`"config/${H}/${H}.local.js"`},{from:`"config/${H}/${H}.ts"`,to:`"config/${H}/${H}.local.ts"`}];else return[];return[{from:`"config/${H}/${H}"`,to:`"config/${H}/${H}.${$}"`},{from:`"config/${H}/${H}.js"`,to:`"config/${H}/${H}.${$}.js"`},{from:`"config/${H}/${H}.ts"`,to:`"config/${H}/${H}.${$}.ts"`}]}).reduce((H,D)=>H.concat(D),[]),M=[...!$&&(b.existsSync(j.join(Y,"env.local"))||b.existsSync(j.join(Y,"env.local.js"))||b.existsSync(j.join(Y,"env.local.ts"))||b.existsSync(j.join(Y,"env.local.tsx"))||b.existsSync(j.join(Y,"env.local.jsx")))?[{from:'"config/env"',to:'"config/env.local"'},{from:'"config/env.js"',to:'"config/env.local.js"'},{from:'"config/env.ts"',to:'"config/env.local.ts"'}]:$?[{from:'"config/env"',to:`"config/env.${$}"`},{from:'"config/env.js"',to:`"config/env.${$}.js"`},{from:'"config/env.ts"',to:`"config/env.${$}.ts"`}]:[],...X];if(M.length>0)console.warn(`

  ${W.yellowBrightBold("Using the following mappings for app config:")}

  \t${W.cyanBrightBold(M.map((H)=>`\n  ${H.from} => ${H.to}`).join("\n\t"))}

      `);return B$(M)}catch(Z){console.error(Z),console.error(W.redBrightBold(`
      App config plugin failed to load. The default config paths will be used
      and any specific environment requested will be ignored.
    `))}}var w$=L(()=>{I();I$()});import*as V$ from"vite";import V1 from"fs-extra";import w3 from"ignore";import e from"path";async function C$($){if(console.warn(W.cyanBright("Building client files for the distribution.")),process.env.VITE_RELEASE_VERSION=process.env.VITE_RELEASE_VERSION||await w(),process.env.FORCE_BUILD!=="true"){if(!V1.existsSync(e.resolve("app/client"))||z0.ignores("app/client")){console.error(`Tried to make a release for the web app client, but no app/client entry file was found. (or was gitignored):\n\t${e.resolve("app/client")}`);return}}const K="development";process.env.NODE_ENV="production",console.warn(`Releasing ${W.yellowBrightBold("app/client")} for Environment:`,W.cyanBrightBold($)),process.env.BUILD_ENV=$;const Y=await o();if(Y.plugins=[T$($),...Y.plugins||[]],Y.logLevel="warn",Y.mode="production",Y.root=e.resolve("app/client"),Y.build.outDir=e.resolve("dist/app/client",$),Y.build.watch=void 0,Y.build.rollupOptions.output={dir:Y.build.outDir,entryFileNames:"index.js",chunkFileNames:"index.js",manualChunks:void 0},await V$.build(Y),process.env.NODE_ENV=K,!V1.existsSync(e.resolve(`dist/app/client/${$}/index.js`)))console.error("\n\nFailed to create Client output bundle. Exiting process...\n\n"),process.exit(1)}var U$,z0;var S$=L(()=>{_1();I();y();w$();U$=e.resolve(".gitignore"),z0=w3.default();if(V1.existsSync(U$))z0=z0.add(V1.readFileSync(U$).toString())});async function $1($=[]){const K=await P();if($1.optimize){if(K[1]==="bunx")return _(K[1],["--bun",...$])}return _(K[1],[...$])}var J0=L(()=>{C();n();$1.optimize=!0});import C1 from"fs-extra";import z1 from"path";async function S1(){if(!C1.existsSync(z1.resolve("ui")))return;C1.ensureDir(z1.resolve("dist/ui")),console.warn(W.yellowBrightBold("Generating .d.ts files...")),$1(["tsc","--emitDeclarationOnly","--declaration","--outDir","dist/types","--project",z1.resolve("tsconfig.json")]);const $=C1.readdirSync(z1.resolve("dist/types"));for(let K of $){if(K==="ui"||K==="util")continue;console.warn(W.yellowBright(`Removing types for folder: ${K}`)),C1.removeSync(z1.resolve("dist/types",K))}}var H0=L(()=>{I();J0()});import U3 from"fs-extra";import V3 from"path";async function E$(){return U3.readJSONSync(V3.resolve("package.json")).name||""}var b$=L(()=>{});import*as R$ from"vite";import E1 from"fs";import C3 from"ignore";import u from"path";async function P$(){if(console.warn(W.cyanBright("Copying ui files for the distribution.")),process.env.VITE_RELEASE_VERSION=process.env.VITE_RELEASE_VERSION||await w(),!process.env.FORCE_BUILD){if(!E1.existsSync(u.resolve("ui"))||F0.ignores("ui")){console.error(`"No library project found (or was gitignored) for bundling release at:\n\t${u.resolve("ui")}`);return}}if(console.warn(W.yellowBrightBold("Starting Vite client build...")),!E1.existsSync(u.resolve("ui/index.ts"))){console.error("The UI folder project has no index.ts entry point to create the library.");return}await S1(),console.warn(W.yellowBrightBold("Building library bundle..."));const $=await o();$.logLevel="warn",$.root=u.resolve("ui"),$.build.lib={entry:u.resolve("ui/index.ts"),name:(await E$()).split("@").join("").split("/").join("_"),fileName:"index"},$.mode="production",$.root=u.resolve("app/client"),$.build.outDir=u.resolve("dist/ui"),$.build.watch=void 0,$.build.rollupOptions.output={dir:$.build.outDir,entryFileNames:"index.js",chunkFileNames:"index.js",manualChunks:void 0};const K=Object.keys(await h());console.warn("Externalized Libraries that will not be included in the bundle:",K),$.build.rollupOptions={...$.build.rollupOptions,external:K},await R$.build($)}var j$,F0;var k$=L(()=>{_1();I();H0();q1();b$();y();j$=u.resolve(".gitignore"),F0=C3.default();if(E1.existsSync(j$))F0=F0.add(E1.readFileSync(j$).toString())});import p from"fs-extra";import x from"path";async function y$(){process.env.VITE_RELEASE_VERSION=process.env.VITE_RELEASE_VERSION||await w(),console.warn(W.cyanBright("Copying story files for the distribution."));const $=x.resolve("dist/stories"),K=x.resolve("ui/stories"),Y=x.resolve("dist");if(!p.existsSync(K)){console.error(`Could not find stories directory:\n\t${K}`);return}p.ensureDirSync($),p.copySync(K,$);const Z=x.resolve("package.json"),G={name:p.readJSONSync(Z).name||"unknown",private:!0,main:"./ui/index.js",types:"./types/ui/index.d.ts",dependencies:{},repository:{},scripts:{},devDependencies:{}};console.warn("Writing distribution package.json:",x.resolve(Y,"package.json")),p.writeJSONSync(x.resolve(Y,"package.json"),G),await R(500),p.ensureDirSync(x.resolve(Y,"components")),G.main="../ui/index.js",G.types="../types/ui/index.d.ts",console.warn("Writing distribution package.json:",x.resolve(Y,"components/package.json")),p.writeJSONSync(x.resolve(Y,"components/package.json"),G),await R(500),console.warn("Finished copying stories.")}var x$=L(()=>{I();y();a()});var v$={};E(v$,{default:()=>{{return j1}}});import b1 from"fs-extra";import K1 from"path";async function S3(){if(process.env.QUICK_BUILD==="true")return;if(await d("release",["view"]),!await k("\nShould the release continue being made?"))await U1(!0),process.exit(1)}async function E3(){console.warn("Gathering build targets from:",W.yellowBright(K1.resolve("build.conf.js")));const $=(await import(K1.resolve("build.conf.js"))).BUILD_TARGETS;if(process.env.NODE_ENV="production",console.warn("Building environments",W.redBrightBold(JSON.stringify($))),!Array.isArray($))console.error("build.conf.js must be an array of string values"),process.exit(1);for(let K of $)await C$(K);await P$(),await y$(),await O$()}async function b3(){try{b1.removeSync(K1.resolve("dist"))}catch($){console.warn("No dist folder to clean out.")}b1.ensureDirSync(K1.resolve("dist"))}async function j3(){try{b1.removeSync(K1.resolve("dist/test"))}catch($){console.warn("No test folder to clean out")}try{b1.removeSync(K1.resolve("dist/unit-test"))}catch($){console.warn("No unit-test folder to clean out")}}async function j1(){console.warn("Validating the release..."),await S3(),console.warn("Clear previous build..."),await b3(),console.warn("Bundling project..."),await E3(),console.warn("Final cleanup..."),await j3(),console.warn("Release Build complete!")}var M0=L(()=>{I();D1();X0();Q1();D$();S$();k$();x$()});var h$={};E(h$,{default:()=>{{return P1}}});import u$ from"fs-extra";import R3 from"lodash/groupBy.js";import R1 from"path";import P3 from"lodash/uniq.js";import k3 from"lodash/upperFirst.js";import{compare as y3,inc as x3} from"semver";async function g3($){console.warn("Building release notes..."),console.warn("fetching tags...");const K=await B("git",["tag","--list"]);if(K===null)console.error("Could not get git tags"),process.exit(1);const Y=K.trim().split("\n").sort(y3),Z=Y[(Y.includes($)?Y.indexOf($):Y.length)-1];console.warn("fetching version hash...");const Q=await B("git",["rev-list","-1",`${$}`]);if(Q===null)console.error("Couldn't get current version hash"),process.exit(1);const G=Q.trim();console.warn("fetching previous version hash...");let X=await B("git",["rev-list","-1",`${Z}`]);if(X===null){if(X=await B("git",["rev-list","--max-parents=0","HEAD"]),X===null)console.error("Couldn't get previous version hash"),process.exit(1)}const z=X.trim();console.warn("fetching logs...");const J=await B("git",["log","--pretty=%B",`${z}...${G}`]);if(J===null)console.error("Couldn't get logs"),process.exit(1);const M=J.split("\n").map((A)=>{const[,O="",F=""]=A.match(/^\s*(\w+?)\s*:\s*(.*)\s*$/)||[];return{tag:g$[O.toLowerCase()],message:k3(F)}}).filter((A)=>A.tag),H=R3(M,"tag"),D=m3.filter((A)=>H[A]).map((A)=>{const O=H[A];return`## ${A.replace(/(\w)/,(F)=>F.toUpperCase())}\n\n${O.map(({tag:F,message:T})=>`- [\`${F.toUpperCase()}\`]: ${T}`).join("\n")}`}).join("\n\n");return console.warn("New release notes completed"),D}async function P1($={}){if(console.warn("Generating Release Notes..."),await B("git",["fetch","--tags"])===null)console.error("Couldn't fetch tags"),process.exit(1);const Y=f$(R1.resolve("package.json")),{version:Z="0.0.1"}=Y;console.warn("Current Project version:",{currentVersion:Z});const Q=await g3("HEAD"),G=u3(Q),X=G&&x3(Z,G);if(!X)console.error("Unable to determine next version",{currentVersion:Z}),process.exit(1);if($.tag){if(console.warn("Creating the new tag..."),await B("git",["tag","-a",X,"-m",`Release ${X}`])===null)console.error("Couldn't create tag"),process.exit(1)}if($.updatePackage){console.warn("Updating the package.json...");const J=f$(R1.resolve("package.json"));J.version=X,m$(R1.resolve("package.json"),`${JSON.stringify(J,null,"  ")}\n`)}const z=`## ${X}\n\n${Q}`;if(!Q.trim()&&$.errorOnEmpty)throw new Error("No notes were generated as no semver style messages were found");if($.file){console.warn("Writing the release notes to file:",$.file);const J=R1.resolve($.file),M=v3(J)?f3(J):"";m$(J,`${`${z}\n\n${M}`.trim()}\n`);for(let D=0;D<=100;++D){if(u$.existsSync(J))break;if(D===100)console.warn("Release notes file was not created in time for the final release commit:",W.redBrightBold(J)),process.exit(1)}if(console.warn("Adding fragments to git..."),await B("git",["add","-A"])===null)console.warn("Could not ensure all fragments are added for the next commit."),process.exit(1);if(console.warn("Committing to git..."),await B("git",["commit","-am",`Release ${X}`])===null)console.error("Couldn't commit changes"),process.exit(1);console.warn(`\n\n${W.cyan(z)}\n\n`)}else console.warn(`\n\n${W.cyan(z)}\n\n`);process.env.VITE_RELEASE_VERSION=X}var u3,v3,f3,f$,m$,g$,m3;var L0=L(()=>{I();l();u3=function($){const K=$.toLowerCase().split("\n").map((Y)=>(Y.match(/## (\w+)/)||[])[1]).filter(Boolean);if(K.includes("breaking"))return"major";if(K.includes("added"))return"minor";return"patch"};({existsSync:v3,readFileSync:f3,readJSONSync:f$,writeFileSync:m$}=u$),g$={breaking:"breaking",feat:"added",feature:"added",added:"added",fix:"fixed",fixed:"fixed",hotfix:"fixed",task:"task"},m3=P3(Object.values(g$))});async function k1($){return _("git",["ls-remote",$])}var _0=L(()=>{C()});async function d$($){const K=await B("git",["remote","-v"]);if(K===null)console.warn("Could not list remotes for the git project."),process.exit(1);const Y=K.split(/\r?\n/g),Z=Y.find((G)=>G.indexOf($)>=0);if(!Z)console.warn(q`
      You MUST have a remote named ${$} which points to the repository you
      wish to deploy to.

      ${Y.join("\n")}
    `),process.exit(1);const Q=Z.split(/\s+/g)[1];if(!k1(Q))console.warn(`
      You do not seem to have access to the repo listed in the package json of
      this project. Please ensure you have write access to the repo:
      ${Q}
      and then try to run the release again.
    `),process.exit(1)}var l$=L(()=>{i();l();_0()});async function p$(){const $=await B("git",["rev-parse","--abbrev-ref","HEAD"]);if($===null){console.error("Failed to determine current branch.");return}return $.trim()||void 0}var c$=L(()=>{l()});var i$;var n$=L(()=>{l();c$();i$=async($,K)=>{const Y=await p$();if(!Y)return console.warn("Could not determine current branch."),!1;if(await B("git",["checkout",`${K}`])===null)return console.warn(`Could not checkout branch ${K}`),!1;if(await B("git",["reset","--hard",`${$}/${K}`])===null){if(console.warn(`Could not reset branch ${K}`),await B("git",["checkout",`${Y}`]))console.warn(`Could not return to original branch ${Y}`);return!1}if(await B("git",["checkout",`${Y}`])===null)return console.warn(`Could not return to original branch ${Y}`),!1;return!0}});import h3 from"fs-extra";import d3 from"path";async function s$(){return h3.readJSONSync(d3.resolve("package.json")).repository||{}}var a$=L(()=>{});var r$={};E(r$,{default:()=>{{return t$}}});import y1 from"fs-extra";import x1 from"path";async function l3(){const $=await s$(),K=$.url;if(!$||!($.type!=="gitlab"||$.type!=="git"||$.type!=="bitbucket"||$.type!=="stash"))console.warn(`
      You MUST have a repository specified in your package json to use the
      release script. It must be of 'type: git' and have a valid ssh url to
      your git repo.

      Additionally, you MUST have a remote configured for your project of
      'origin' that matches the repo url listed in your package.json.

      Thus: "git remote -v" SHOULD output a line with
      origin <url in your package json repository field> (push)
    `),process.exit(1);const Y=await B("git",["remote","-v"]);if(Y===null)console.warn("Could not list remotes for the git project."),process.exit(1);const Z=Y.split(/\r?\n/g);if(!Z.find((G)=>G.indexOf(c)>=0&&G.indexOf(K)>=0))console.warn("Could not match package json repository to an origin remote in git CLI",{remoteListProcess:Y,remotes:Z,ENSURE_REMOTE:c,ENSURE_REMOTE_PROJECT:K}),process.exit(1);if(!k1(K))console.warn(`
      You do not seem to have access to the repo listed in the package json of
      this project. Please ensure you have write access to the repo:
      ${K}
      and then try to run the release again.
    `),process.exit(1);if(await r())console.error("You have uncommitted changes or the current state of the project can not be determined. Please commit or stash them before continuing."),process.exit(1);console.warn("Repository validation complete")}async function p3(){if(!await await _("git",["checkout","release"])){if(!await _("git",["checkout","-b","release"]))console.warn("Could not switch to the release branch. Make sure the branch exists locally."),process.exit(1)}if(!await _("git",["fetch",`${c}`]))console.warn("Could not fetch from remote servers."),process.exit(1);if(!await _("git",["reset","--hard",`${c}/dev`]))console.warn("Could not reset branch to dev"),process.exit(1);console.warn("Checked out release branch and updated to dev")}async function i3($){const K=await w();if(!await _("git",["add","-A"]))console.warn("Could not ensure all fragments are added for the next commit."),process.exit(1);await P1({file:"RELEASE_NOTES.md",updatePackage:!0});const Y=await w();if(K===Y)console.warn(`
      The release script did not detect any changes for a release. If you find
      this to be in error or you want to force a new release. Make some commits
      with proper release note formatted messages to trigger a release.
    `),process.exit(1);if($){if(c3()!=="patch")console.error(`
        Cannot create a release for an alternate branch that is not a simple
        patch. Features and breaking changes can ONLY be made on the main branch of
        development.
      `),process.exit(1)}const Z=await B("git",["log","-1","--pretty=%B"]);if(Z===null)console.warn("Could not read the last commit version information"),process.exit(1);const Q=(Z.trim().toLowerCase().split("release ")[1]||"").trim();if(!Q)console.warn("Could not determine release version from the last commit:\n\n",Z.toString(),"\n\n"),process.exit(1);if(y1.existsSync(x1.resolve("ui/release.json"))){try{const G=y1.readJSONSync(x1.resolve("ui/release.json"));G.version=Q,y1.writeJSONSync(x1.resolve("ui/release.json"),G)}catch(G){console.warn("Could not update the release.json file with current library version."),process.exit(1)}if(!await _("git",["add","-A"]))console.warn("Could not ensure the release json was updated for the new version."),process.exit(1);if(!await _("git",["commit","--amend","--no-edit"]))console.warn("Could not amend the release commit to include the release json file."),process.exit(1)}if(Q.includes('"'))console.warn("The update version generated is invalid as it contains invalid characters",{version:Q}),process.exit(1);return console.warn("Updating version to",{version:Q}),Q}async function n3($){if(!await _("git",["tag","-a",$,"-m",`Release ${$}`]))console.warn("Could not make tag for git commit"),process.exit(1)}async function o$($,K,Y,Z,Q){if(!await _("git",["push",Q?"-f":void 0,$,`${Y}:${Z}`]))console.warn(`Could not push release commit to ${$}`),process.exit(1);if(!await _("git",["push",$,K]))console.warn("Could not push tag to the remote repository"),process.exit(1)}async function s3($,K){if($&&$.length>0){if(!await k(q`
        The build and release was successful, would you like to release to the
        specified additional remotes?

        ${W.cyanBrightBold($.join("\n"))}
      `))return}if(!await _("git",["fetch",c]))console.warn("Could not fetch from remote servers."),process.exit(1);for(let Y of $){const[Z,Q,G,X]=Y.split(":");await d$(Z),await i$(c,Q||"master"),await o$(Z,K,Q||"master",G||"master",X==="force")}}async function a3($){process.env.NODE_ENV="production",await l3(),await p3(),await j1();const K=await i3();if(await n3(K),await o$(c,K,"release","release",!0),await k("Would you like to run pr release?"))await d("pr",["release"]);await s3($,K),await U1(!0)}async function t$($){console.warn("Executing release script"),a3($)}var c3,c;var e$=L(()=>{M0();L0();I();i();D1();C();l();_0();l$();w1();X0();n$();Q1();a$();y();c3=function(){try{const K=y1.readFileSync(x1.resolve("RELEASE_NOTES.md"),"utf8").toLowerCase().split("\n").map((Y)=>(Y.match(/## (\w+)/)||[])[1]).filter(Boolean);if(K.includes("breaking"))return"major";if(K.includes("added"))return"minor";return"patch"}catch($){console.error("Could not determine release type after release was created"),process.exit(1)}};c="origin"});var K2={};E(K2,{default:()=>{{return $2}}});async function $2(){await S1()}var Y2=L(()=>{H0()});var q0={};E(q0,{default:()=>{{return Q2}}});import v from"fs-extra";import o3 from"ignore";import S from"path";async function t3($){const K=v.readJSONSync(S.resolve("tsconfig.json"));if(K.exclude=K.exclude||[],K.include=(K?.include||[]).filter((Z)=>!v1.ignores(S.relative("./",Z))),v.writeJSONSync(S.resolve("tsconfig.temp.json"),K),await R(500),$==="watch"){const Z=async()=>{console.warn("Exit TS process");try{v.removeSync(S.resolve("tsconfig.temp.json"))}catch(Q){}process.exit(0)};process.on("exit",Z),process.on("SIGINT",Z),process.on("SIGUSR1",Z),process.on("SIGUSR2",Z),process.on("SIGTERM",Z),process.on("uncaughtException",Z)}if(!_("tsc",["-d",$==="watch"?"--watch":"","--incremental","--noemit","--pretty","--tsBuildInfoFile",S.resolve("node_modules/.cache/tsc/tsc.tsbuildinfo"),"--outDir",S.resolve("dist"),"--project",S.resolve("tsconfig.temp.json")]))console.warn("Failed to compile type declarations"),v.removeSync(S.resolve("tsconfig.temp.json")),process.exit(1);const Y=(K?.include||[]).filter((Z)=>!v1.ignores(S.relative("./",Z))).map((Z)=>S.resolve(Z)).filter((Z)=>v.existsSync(Z)&&!Z.includes("node_modules"));if(Y.length>0){if(!_("eslint",[...Y,"-c",S.resolve(".eslintrc"),"--ext",".ts","--ext",".tsx"]))console.warn("Failed eslint checks."),v.removeSync(S.resolve("tsconfig.temp.json")),process.exit(1)}v.removeSync(S.resolve("tsconfig.temp.json"))}async function Q2($){await t3($)}var Z2,v1;var O0=L(()=>{C();a();Z2=S.resolve(".gitignore"),v1=o3.default();if(v.existsSync(Z2))v1=v1.add(v.readFileSync(Z2).toString())});var X2={};E(X2,{default:()=>{{return G2}}});async function G2(){console.warn(W.yellowBrightBold("Starting server...")),await W1()}var W2=L(()=>{s1();I()});var M2={};E(M2,{default:()=>{{return F2}}});import r3 from"fs-extra";import D0 from"path";async function H2($){if(!r3.existsSync($))return console.warn("Attempted to start a server but no server distribution was found at",$),!1;return await _("bun",[`${$}`]),!0}async function z2(){const $=D0.resolve("docs/index.js");return await H2($)}async function J2(){process.env.RESOURCE_PATH=D0.resolve("dist/app/client");const $=D0.resolve("dist/app/server/index.js");return await H2($)}async function F2($,K){const{PORT:Y="80"}=process.env;process.env.PORT=Y;let Z=!1;switch($){case"app":Z=await J2();break;case"devops":Z=await z2();break;default:if($)console.warn("Invalid target for start script specified",$);break}if(!Z){if(Z=await J2(),Z)return;if(Z=await z2(),Z)return}}var L2=L(()=>{C()});import e3 from"fs-extra";import A0 from"path";async function _2(){const $=A0.resolve("tsconfig.json");if(!e3.existsSync($))throw new Error("Target project does not have a TSConfig");const K=Boolean(process.env.DEBUG),Y=process.env.PATTERN,Z=process.env.WATCH,Q=process.env.LESS,G=A0.resolve("jest.config.js");_.silent=!0;try{if(K)_("node",["--inspect-brk",A0.resolve("node_modules/.bin/jest"),"--runInBand",Z?"--watchAll":"","--verbose",Q==="true"?"false":void 0,"--colors","--config",G,Y?`--testNamePattern ${Y}`:""]);else $1(["jest",Z?"--watchAll":"","--verbose",Q==="true"?"false":void 0,"--colors","--config",G,Y?`--testNamePattern=${Y}`:""])}catch(X){console.warn("Tests failed. Please look at logs to see the errors discovered")}console.warn(W.cyanBright("Tests complete"))}var q2=L(()=>{I();J0();C()});var D2={};E(D2,{default:()=>{{return O2}}});async function O2(){console.warn("Running unit tests..."),await _2()}var A2=L(()=>{q2()});var w2={};E(w2,{default:()=>{{return T2}}});import N2 from"fs";import B2 from"path";import I2 from"rimraf";async function T2(){const $=B2.resolve("./node_modules/.cache/"),K=B2.resolve("./build");if(N2.existsSync($))I2.sync($),console.warn("Cache: Clean complete");else console.warn("Cache: Already clean");if(N2.existsSync(K))I2.sync(K),console.warn("Build: Clean complete");else console.warn("Build: Already clean");if(await _("bun",["pm","cache","rm"]))console.warn("Bun: Clean complete");else console.warn("Bun: Already clean")}var U2=L(()=>{C()});import V2 from"path";import{createRequire as $4} from"module";async function f1($,K){const Q=$4(import.meta.url).resolve($).split("node_modules"),G=Q[0],X=Q[1].split(V2.sep)[1];return V2.join(G,"node_modules",X,"node_modules",".cache",K)}var C2=L(()=>{});var E2={};E(E2,{default:()=>{{return S2}}});import K4 from"fs-extra";import Y1 from"path";import Y4 from"url";async function Z4($,K,Y){const Z=await import("puppeteer"),Q=await f1("puppeteer","pr-release"),G=await Z.launch({headless:!1,userDataDir:Y1.resolve(J1,Q),defaultViewport:null}),X=await G.newPage();console.warn("Opening project url..."),await X.goto($);const z=await X.evaluate(()=>document.body.getAttribute("data-project-id"));if(!z){console.warn("No project id found, User login required...");let M=!0;G.on("disconnected",()=>{if(!M)return;console.warn("Browser was closed or crashed. Try the command again."),process.exit(1)}),await X.goto($),await X.waitForFunction(()=>{const H=document?.body?.getAttribute("data-project-id");return H!==null&&H!==void 0},{timeout:0}),await X.close(),M=!1}else await X.close();console.warn("Project ID found:",z,"\nOpening merge request...");const J=async(M,H,D)=>{const A=await G.newPage();await A.goto(`${$}/-/merge_requests/new?${D?"utf8=%E2%9C%93&":""}merge_request%5Bsource_project_id%5D=${z}&merge_request%5Bsource_branch%5D=${encodeURIComponent(M)}&merge_request%5Btarget_project_id%5D=${z}&merge_request%5Btarget_branch%5D=${H}`),await A.waitForFunction(()=>{const O=document.querySelector("#merge_request_title");return O!==null&&O!==void 0},{timeout:0}),await A.evaluate((O)=>{let F=document.querySelector("#merge_request_title");if(F)F.value=`Release ${O}`;if(F=document.querySelector("#merge_request_description"),F)F.value=`Release ${O}`;if(F=document.querySelector("#merge_request_force_remove_source_branch"),F)F.checked=!1,F.value="0"},K),await new Promise((O)=>{A.on("close",()=>{O(void 0),console.warn("Gitlab ticket process finished\n\n")})})};console.warn("\n\nWaiting for browser windows to be closed...\n\n"),await Promise.all([J("release","dev"),J("release",Y)]),G.close()}async function N0($,K,Y,Z){const Q=await import("puppeteer"),G=await f1("puppeteer","pr-release");let X=await Q.launch({headless:!Z,userDataDir:Y1.resolve(J1,G),defaultViewport:null});const z=await X.newPage();if(Z){console.warn("User login required...");let D=!0;X.on("disconnected",()=>{if(!D)return;console.warn("Browser was closed or crashed. Try the command again."),process.exit(1)});const A="https://github.com/login";console.warn("Opening github login page: ",A),await z.goto(A),await z.waitForFunction(()=>{const O=document?.body?.getAttribute("class")?.split(" ").find((F)=>F.startsWith("logged-in"));return O!==null&&O!==void 0},{timeout:0}),D=!1}else console.warn("Opening project url: ",$),await z.goto($);console.warn("Checking for logged-in attribute on body...");const J=await z.evaluate(()=>{return console.warn("logged-in check:",document?.body?.getAttribute("class")?.split(" ").find((D)=>D.startsWith("logged-in"))),document?.body?.getAttribute("class")?.split(" ").find((D)=>D.startsWith("logged-in"))});if(console.warn("Loggin in check:",J),!J&&Z)await X.close(),console.error("Failed to log in the user for github."),process.exit(1);else if(!J){console.warn("Logged-in not found on body, login might be needed..."),await X.close(),N0($,K,Y,!0);return}else X.close();const M={headless:!1,userDataDir:Y1.resolve(J1,G),defaultViewport:null};X=await Q.launch(M);const H=async(D,A)=>{const O=await X.newPage();await O.goto(`${$}/compare/${A}...${D}`),await O.waitForFunction(()=>{const F=document.querySelector("#repo-content-pjax-container > div > div.js-details-container.Details.js-compare-pr > div > button");return F?.click(),F!==null&&F!==void 0}),await O.evaluate(async(F)=>{let T=document.querySelector("#pull_request_title");if(T)T.value=`Release ${F}`;if(T=document.querySelector('[name="pull_request[body]"]'),T)T.value=`Release ${F}`},K),await new Promise((F)=>{O.on("close",()=>{F(void 0),console.warn("Github ticket process finished\n\n")})})};console.warn("\n\nWaiting for browser windows to be closed...\n\n"),await Promise.all([H("release","dev"),H("release",Y)]),X.close()}async function Q4($,K,Y,Z){const Q=await import("puppeteer"),G=await f1("puppeteer","pr-release");let X=await Q.launch({headless:!Z,userDataDir:Y1.resolve(J1,G),defaultViewport:null});const z=await X.newPage();if(Z){console.warn("User login required...");let D=!0;X.on("disconnected",()=>{if(!D)return;console.warn("Browser was closed or crashed. Try the command again."),process.exit(1)});const A=$;console.warn("Opening azure repo login page: ",A),await z.goto(A),await z.waitForFunction(()=>{const O=window.sessionStorage.msameid;return O!==null&&O!==void 0},{timeout:0}),D=!1}else console.warn("Opening project url: ",$),await z.goto($);console.warn("Checking for logged-in attribute on body...");const J=await z.evaluate(()=>{return console.warn("logged-in check:",window.sessionStorage.msameid),window.sessionStorage.msameid});if(console.warn("Loggin in check:",J),!J&&Z)await X.close(),console.error("Failed to log in the user for azure."),process.exit(1);else if(!J){console.warn("MS id not found, login might be needed..."),await X.close(),N0($,K,Y,!0);return}else X.close();const M={headless:!1,userDataDir:Y1.resolve(J1,G),defaultViewport:null};X=await Q.launch(M);const H=async(D,A)=>{const O=await X.newPage();await O.goto(`${$}&sourceRef=${D}&targetRef=${A}`),await O.waitForFunction(()=>{const F=document.querySelector("button.primary");return F!==null&&F!==void 0}),await O.evaluate(async(F)=>{let T=document.querySelector('[aria-label="Enter a title"]');if(T)T.value=`Release ${F}`;if(T=document.querySelector('[aria-label="Description"]'),T)T.value=`Release ${F}`},K),await new Promise((F)=>{O.on("close",()=>{F(void 0),console.warn("Azure project ticket process finished\n\n")})})};console.warn("\n\nWaiting for browser windows to be closed...\n\n"),await Promise.all([H("release","dev"),H("release",Y)]),X.close()}async function S2($,K,Y="master",...Z){if(!(new Set(["gitlab","git","github","azure"])).has(K))console.error(`Unsupported repo type: ${K}`),process.exit(1);if(await r())console.error("You have uncommitted changes or the current state of the project can not be determined. Please commit or stash them before continuing."),process.exit(1);const X=K4.readJsonSync(Y1.resolve("package.json")).version;switch(K){case"gitlab":await Z4($,X,Y);break;case"git":case"github":await N0($,X,Y);break;case"azure":await Q4($,X,Y);break;default:console.warn("No supported repo type found")}}var J1;var b2=L(()=>{C2();w1();J1=Y4.fileURLToPath(new URL(".",import.meta.url))});I();import*as G4 from"commander";import X4 from"inquirer-autocomplete-prompt";import W4 from"inquirer";import j2 from"path";import z4 from"yargs";I();i();import E0 from"fs-extra";import b0 from"path";I();import w0 from"fs";import U0 from"path";function T0($){const K=$.split(/\r?\n/),Y={};let Z=null,Q=null;return K.forEach((G)=>{if(G=G.trim(),G===""||G.startsWith("#"))return;if(G.endsWith("{")){Z=G.split(/\s+/)[0],Y[Z]={};return}if(G==="}"){Z=null,Q=null;return}const X=G.match(/^([\w.]+)\s*=\s*(.*)$/);if(X){const J=X[1];let M=X[2];if(!isNaN(parseFloat(M)))M=parseFloat(M);else if(M==="true")M=!0;else if(M==="false")M=!1;if(Q)Y[Z??"null"][Q][J]=M;else if(Z)Y[Z][J]=M;else Y[J]=M;return}const z=G.match(/^([\w.]+)\.([\w.]+)\s*=\s*(.*)$/);if(z){const J=z[1],M=z[2],H=z[3];if(!Y[J])Y[J]={};if(!Y[J][M])Y[J][M]={};Y[J][M][H]=null,Z=J,Q=M;return}console.error(`Unrecognized line: ${G}`)}),Y}function V0($){try{if(!w0.existsSync(U0.resolve(".env")))return;const K=w0.readFileSync(U0.resolve($||".env"),"utf8"),Y=T0(K);Object.entries(Y).forEach(([Z,Q])=>{if(typeof Q==="string")process.env[Z]=Q;else if(typeof Q==="number")process.env[Z]=Q.toString();else if(typeof Q==="boolean")process.env[Z]=Q.toString()})}catch(K){if(K instanceof Error)console.error(W.red("Error reading .env file:\n",W.yellow(K.stack||K.message)))}}Z1();Q1();import g2 from"fs-extra";import h2 from"inquirer";import{stripIndent as d2} from"common-tags";async function S0($,K,Y,Z,Q,G){let X=G||!1;if(g2.existsSync($)){const{result:z}=await h2.prompt([{type:"confirm",name:"result",message:d2`${K}`,default:G}]);if(z)Y($),Q?.($);X=z}else Y($),Z?.($);return X}async function l2(){const $=(await import(b0.resolve("env.config.ts"))).default;if(!$)throw new Error("No env.config.ts file found.");if(!Array.isArray($))console.error("env.config.ts is not formatted correctly. Please follow the correct type convention.");return $}async function g1($){V0();try{const K=await l2(),Y=[],Z=[];if(K.forEach((Q)=>{if(!Q)return;if(Q.required){if(!process.env[Q.name])Y.push(q`
              Missing: ${Q.name}\nDesription: ${Q.description}
            `)}else if(!process.env[Q.name]&&Q.warn!==!1)Z.push(q`
              Missing: ${Q.name}\nDesription: ${Q.description}
            `)}),Z.length>0)console.warn(W.yellowBrightBold("The following environment variables are recommended but missing from your environment:\n")),console.warn(W.yellowBright(q`
          ${Z.join("\n")}
        `));if(Y.length>0)console.error(W.redBrightBold("The following environment variables are required but missing from your environment:\n")),console.error(W.redBright(q`
          ${Y.join("\n")}
        `));if(Y.length>0){if($){if(await k(q`
          There seems to be some missing environment variables. Would you like
          to generate a .env file with the default values specified in the
          env.config file?
        `)){const G=[];for(let M of K)G.push([M.name,C0(M.default)?M.default:f(M.default)?await M.default():void 0]);const X=G.filter((M)=>M[1]).map((M)=>`${M[0]}=${M[1]}`).join("\n");if(!X)console.warn(q`
              There are no defaults available for this env.config. So we can not
              generate an env file you. Please review the env.config.ts file and
              properly set the default values for the required environment
              variables.
            `);const z=b0.resolve(".env");if(!await S0(z,q`
              There appears to already be a .env file.
              Would you like to add the missing defaults to it?
            `,()=>{},()=>E0.writeFile(z,X),()=>{E0.appendFileSync(z,`\n${X}`)},!1))console.error("Did not write the .env file. Please correct the env and try again."),process.exit(1);return console.warn("Attempting to build the env again and continue with the command..."),g1(!1)}}process.exit(1)}}catch(K){console.warn(q`
      No ${W.cyanBrightBold("env.config.ts")} file found. Environment will not be validated.
    `)}}i();import c2 from"fs-extra";import i2 from"inquirer";import n2 from"path";C();n();Z1();async function s($,K,Y){const Z=await P(),Q=$.filter(f);return _(Z[0],["i",Y?"--no-save":null,K?`-${K}`:null,...Q])}C();import p2 from"fuzzy";var j0=($)=>async(K,Y)=>{let Z=[];if($ instanceof Set)Z=Array.from($);else Z=$;return p2.filter(Y||"",Z).map((Q)=>Q.string)};n();async function R0($){try{return await import($),!0}catch(K){return console.error("Requested package is not available in this current project:",$),!1}}a();async function P0($,K){const Y=$||["puppeteer"];for(let Z of Y)if(console.warn("Checking on dependency availability:",Z),!await R0(Z)){let G=K;if(!G)G=(await i2.prompt([{type:"autocomplete",name:"resolution",message:`How do you want to resolve the missing package "${Z}":`,source:j0([m.InstallOnce,m.InstallAbove,m.DoNothing])}])).resolution;switch(G){case m.Install:await s([Z],"E");break;case m.InstallOnce:s([Z],"E",!0);break;case m.InstallAbove:{const X=process.cwd();process.chdir("..");const z=await P();if(!c2.existsSync(n2.resolve("package.json")))_(z[0],["init","-y"]);await s([Z],"E"),process.chdir(X),await R(100);break}default:process.exit(1)}}}var m;(function(Q){Q["Install"]="Install to current project";Q["InstallOnce"]="Install once to current project";Q["InstallAbove"]="Install in parent directory (Makes package available to all peer projects)";Q["DoNothing"]="Do Nothing (this will end this current process as the package is required)"})(m||(m={}));var B0=function(){return m1.debug=V.debug,m1.verbose=V.verbose,m1.pattern=V.pattern,m1};async function O4(){await g1(!0),V.parse(process.argv)}W4.registerPrompt("autocomplete",X4);var{Command:J4}=G4,V=new J4,m1={};V.version("0.0.1");V.option("-v, --verbose","Outputs more detailed information during crashes.");V.option("--debug [param]",q`
    Provides debugging contextual information various commands might use to
    aid in developing Devops.
  `);V.option("-p, --pattern [param]",q`
    Provides a pattern for certain operations to utilize. This is primarily
    used by unit tests to filter tests to specified tests.
  `);var R2=V.command("dev").description(q`
    These are the commands associated with starting up developer environments
    for various project types or portions of a project.
  `);R2.command("vite").description(q`
      Starts up a developer environment that performs incremental builds while
      developing within the lib and app folders. Uses vite and vite
      config.
    `).action(async()=>{(await Promise.resolve().then(() => (g0(),u0))).default().catch(($)=>{console.warn("dev-vite process exited unexpectedly"),console.warn($.stack||$.message),process.exit(1)})});R2.command("storybook").option("-i, --include <include...>","Additional storybook modules to load into storybook. These are the names of properly formatted dependencies installed into node_modules.").description(q`
      Starts a storybook instance for developing the UI components of the
      project. This makes the "ui/stories" folder in the project the expected
      development point.
    `).action(async({include:$})=>{(await Promise.resolve().then(() => (r1(),t1))).default("",$,j2.resolve(process.cwd()),B0()).catch((K)=>{console.warn("storybook process exited unexpectedly"),console.warn(K.stack||K.message),process.exit(1)})});var H4=V.command("storybook");H4.command("run").option("-i, --include <include...>","Additional storybook modules to load into storybook. These are the names of properly formatted dependencies installed into node_modules.").description(q`
      Starts a storybook instance for developing the UI components of the
      project. This makes the "ui/stories" folder in the project the expected
      development point.
    `).action(async({include:$})=>{(await Promise.resolve().then(() => (r1(),t1))).default("",$,j2.resolve(process.cwd()),B0()).catch((K)=>{console.warn("storybook process exited unexpectedly"),console.warn(K.stack||K.message),process.exit(1)})});V.command("url [uri...]").description(q`
      Simple command to open a specified URL in the browser.
    `).action(async($)=>{(await Promise.resolve().then(() => (_$(),L$))).default($).catch((K)=>{console.warn("url process exited unexpectedly"),console.warn(K.stack||K.message),process.exit(1)})});var H1=V.command("release").description(q`
    These commands are used for facilitating distribution releases of
    applications. This includes tools for building th dist folder fragments,
    viewing the expected release notes, and actually performing a complete
    release cycle.
  `);H1.command("deploy [add-remote...]").description(q`
      Performs actions necessary to update the distribution of the project.
      This will automatically update release notes, tag the release, and
      commit and push to a 'release' branch which will be ready for merging
      into master and dev.

      Specify additional remotes to deploy to via the add-remote option.
      This will deploy the release to additional remotes (AFTER all other normal
      deploy operations complete). This value is the NAME of the remote as it
      appears when you perform a "git remote -v" command.

      You can specify a specific target branch via a colon: remote:branch
      Otherwise, this will use the same main branch as configured for this
      project.
    `).action(async($)=>{s([]),(await Promise.resolve().then(() => (e$(),r$))).default($).catch((K)=>{console.warn("release-deploy process exited unexpectedly\n",K.stack||K.message),process.exit(1)})});H1.command("types").description(q`
      Updates JUST the types in the dist folder. These are the same types
      generated when building a release.
    `).action(async()=>{(await Promise.resolve().then(() => (Y2(),K2))).default().catch(($)=>{console.warn("release-types process exited unexpectedly\n",$.stack||$.message),process.exit(1)})});H1.command("view").description(q`
      This runs the release-view script. For this case, it will only display
      the release notes in the console. Actual generated release notes are a
      part of the release process.
    `).action(async()=>{(await Promise.resolve().then(() => (O0(),q0))).default("").then(async()=>{console.warn(W.cyanBrightBold("TS check passed, generating notes...")),(await Promise.resolve().then(() => (L0(),h$))).default().catch(($)=>{console.warn("release-notes process exited unexpectedly",$.stack||$.message),process.exit(1)})}).catch(($)=>{console.warn(W.redBrightBold(q`
              Failed TS check. Release notes will not be produced until all TS
              errors are resolved.
            `)),console.warn($.stack||$.message),process.exit(1)})});H1.command("build").description(q`
      This runs the release-build script. This generates all of the release
      fragments. This should ONLY be used for testing and experimenting. Actual
      release fragments should be properly created and deployed using the
      release deploy command.
    `).action(async()=>{(await Promise.resolve().then(() => (M0(),v$))).default().catch(($)=>{console.warn("release-deploy process exited unexpectedly\n",$.stack||$.message),process.exit(1)})});var F4=H1.command("start").description(q`
      This starts up released related processes. This includes things like
      starting up the dev server without any additional builds or auto
      configuration for development.
    `);F4.command("server").description(q`
      Starts up the app server without any additional builds etc. Use the
      environments:

        BUILD_MODE: Targets an env to run the server for.
        RESOURCE_PATH: The path to the static files to serve.
    `).action(async()=>{(await Promise.resolve().then(() => (W2(),X2))).default().catch(($)=>{console.warn("release-start-server process exited unexpectedly\n",$.stack||$.message),process.exit(1)})});V.command("start [target]").description(q`
      This fires up a server to make any static content available for being
      served.
      There are a few options for what content will be served by this script:

      - The web app
      - Devops API

      The start script will automatically pick the web app over the devops
      files, but you can specify a target if you have a devops API and a web
      app:

      - app
      - devops
    `).action(async($)=>{(await Promise.resolve().then(() => (L2(),M2))).default($,B0()).catch((K)=>{console.warn("start process exited unexpectedly"),console.warn(K.stack||K.message),process.exit(1)})});var M4=V.command("test").description(q`
    These commands are used for running tests. This includes tools for
    running unit tests a single time or in a watch mode.

    Use the environment variables for modifying behavior:

    ${W.yellowBrightBold("PATTERN")} - This causes the tests to only run on
    files that match the pattern

    ${W.yellowBrightBold("LESS")} - This removes the verbose output list of
    all tests ran
  `);M4.command("run").description(q`
      Runs all unit tests in the unit-test folder once.
    `).action(async()=>{(await Promise.resolve().then(() => (A2(),D2))).default().catch(($)=>{console.warn("test-run process exited unexpectedly"),console.warn($.stack||$.message),process.exit(1)})});var L4=V.command("clean").description(q`
    Common cleaning tools for various fragments within the project.
  `);L4.command("cache").description(q`
      Cleans out build and cache files to help ensure a complete rebuild takes
      place.
    `).action(async()=>{(await Promise.resolve().then(() => (U2(),w2))).default().catch(($)=>{console.warn("clean-cache process exited unexpectedly"),console.warn($.stack||$.message),process.exit(1)})});var _4=V.command("ts").description(q`
    These commands are used for running typescript. This includes tools for
    running typescript compilation a single time or in a watch mode.
  `);_4.command("run").description(q`
      Runs typescript compilation to check for errors. Does NOT emit files, thus
      is a good mechanism for checking a build before running a release.
    `).action(async()=>{(await Promise.resolve().then(() => (O0(),q0))).default("").catch(($)=>{console.warn("ts process exited unexpectedly"),console.warn($.stack||$.message),process.exit(1)})});var q4=V.command("pr").option("--repoUrl <value>",q`
      The https URL to the repo to make the PR into
    `).option("--repoType <value>",q`
    The repository type to make the PR into. Supported types are: git, gitlab
  `).option("--masterBranch <value>",q`
    This indicates which branch is the master/main of the repository.
  `);q4.command("release").description(q`
      This creates two PRs that merges the current remote release branch into
      the remote dev and master branches.
    `).action(async()=>{const{repoUrl:$,repoType:K,masterBranch:Y}=z4(process.argv).argv;if(!$||!K||!Y)console.warn("You must specify both --repoUrl and --repoType to use this command"),process.exit(1);await P0().catch(()=>process.exit(1)),console.warn("Dependency checks passed, continuing..."),(await Promise.resolve().then(() => (b2(),E2))).default($,K,Y).catch((Z)=>{console.warn("pr-release process exited unexpectedly"),console.warn(Z.stack||Z.message),process.exit(1)})});O4();
